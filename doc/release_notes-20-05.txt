

              ===============================================
              Release notes for the Genode OS Framework 20.05
              ===============================================

                               Genode Labs



;intro
;@nfeske




Capability-based security using seccomp on Linux
################################################

_This section was written by Stefan Th√∂ni of [https://gapfruit.com/ - gapfruit AG] who_
_conducted the described line of work in close collaboration with Genode Labs._

My goal for the Genode Community Summer 2019 was to enable seccomp for
base-linux to achieve an intermediate level of security for a Genode system
running on Linux. To get any security benefit from seccomp, it turned out the
RPC mechanisms of base-linux needed to be significantly reworked to prevent
processes from forging any capabilities.

The new capability-based security on Linux maps each capability to a pair of
socket descriptors, one of which can be transferred along socket connections
using kernel mechanisms. Each invocation of a capability uses the received
socket descriptor to address the server which in turn uses the epoll framework
of the Linux kernel to get notification of incoming messages and the server
side socket descriptor to securely determine the invoked RPC object.
Capabilities which are passed back to the server rather than invoked can be
securely identified by their inode number. This way, no client can forge any
capability.

With the hard part finally finished thanks to a
[https://github.com/genodelabs/genode/pull/3581 - concerted effort] led by
Norman Feske, I could turn back to seccomp. This Linux kernel mechanism
restricts the ability of a process to use syscalls. Thanks to the small
interface used by Genode processes, the whitelist approach worked nicely,
restricting all Genode processes to just 25 syscalls on x86, none of which can
access any file on the host system. Instead all access to the host system must
go through Genode RPC mechanisms to one of the hybrid components which are not
yet subject to seccomp. Although some global information of the host system
may still be accessed, the possibilities of escaping a sandboxed Genode
process are vastly reduced.

Note that these changes are transparent to any user of base-linux in all but
one way: The Genode system might run out of socket descriptors in large
scenarios. If this happens, you need to increase the hard open file descriptor
limit. See 'man limits.conf' for further information.


Feature-completeness of the consistent block encrypter
######################################################

;@m-stein


New revision of the Genode Foundations book
###########################################

The "Genode Foundations" book received its annual update. It is available at
the [https://genode.org] website as a PDF document and an online version.
The most noteworthy additions and changes are:

: <div class="visualClear"><!-- --></div>
: <p>
:  <div style="clear: both; float: left; margin-right:20px;">
:   <a class="internal-link" href="https://genode.org">
:    <img class="image-inline" src="https://genode.org/documentation/genode-foundations-title.png">
:   </a>
:  </div>
: </p>

* The feedback-control-system composition
* Removal of outdated components and APIs (noux, slave API)
* Additional features ('<alias>', unlabeled LOG sessions)
* Recommended next steps after reading of the getting-started section
* Updated API reference ('Mutex', 'Blockade', 'Request_stream', 'Sandbox')

: <div class="visualClear"><!-- --></div>

To examine the changes in detail, please refer to the book's
[https://github.com/nfeske/genode-manual/commits/master - revision history].


The great consolidation
#######################

;@nfeske

Updated block servers using 'Request_stream' API
================================================

During the previous release cycle we did adjust Genode's AHCI driver as well as
the partition manager to take advantage of the modern 'Request_stream' API, and
thus, deprecating the ancient 'Bock::Driver' interface. With the current release
we have continued this line of work by introducing the 'Request_stream' API in
our USB block driver and Genode's native NVMe driver with the ultimate goal to
eliminate the 'Block::Driver' interface within all Genode components.

Additionally, the NVMe driver received a major polishing regarding the handling
of DMA memory. The handling of this type of memory got substantially simplified
and the driver now can use the shared memory of a client session directly, and
therefore, save expansive copy operations.


Migration from 'Lock' to 'Mutex' and 'Blockade'
===============================================

Since the last release we continued the cultivation of 'Mutex' and 'Blockade'
across the repositories 'base' and 'os' of the Genode framework. The changes
are transparent to a Genode developer mostly. One noticeable
change is that the Genode::Synced_interface now requires a 'Mutex' as template
argument, the 'Lock' class is not supported anymore. The known user outside
of the repository of 'os' and 'base', namely Seoul, got adjusted to this change.


Retired Noux runtime environment
================================

We introduced Noux in Genode
[https://genode.org/documentation/release-notes/11.02#Noux_-_an_execution_environment_for_the_GNU_userland - version 11.02]
as a runtime environment or executing command-line-based GNU userland software
on top of Genode. It soon became an invaluable feature that nicely bridged the
gap between Genode's rigid component architecture and the use of broadly
popular Unix tools such as Vim, bash, and make.
In particular, without Noux as a stepping stone, we couldn't have conceived the
[https://genode.org/download/sculpt - Sculpt] operating system.
Code-wise, Noux was the starting point of Genode's unique
[https://genode.org/documentation/release-notes/14.05#Per-process_virtual_file_systems - VFS]
infrastructure that we take for granted today.

That said, the success story of Noux was not without problems.
For example, despite significant feature overlap between Noux and Genode's
libc, both runtime environments remained distinct from each other. Programs
had to be targeted to either environment at build time.
As another problem, the fork/execve mechanism of Noux required a few special
hooks in Genode's base system that are complicated. Still, those hooks were
insufficient to accommodate Noux on top of the Linux kernel.

One year ago, a "divine" plan of how the feature set of Noux could be
implemented in our regular C runtime struck us. It
[https://genode.org/documentation/release-notes/19.11#C_runtime_with_improved_POSIX_compatibility - turned out]
to work as we hoped for.
During the release cycles of versions
[https://genode.org/documentation/release-notes/19.08#Consolidation_of_the_C_runtime_and_Noux - 19.08],
[https://genode.org/documentation/release-notes/19.11#C_runtime_with_improved_POSIX_compatibility - 19.11], and
[https://genode.org/documentation/release-notes/20.02#POSIX_compatibility_improvements - 20.02],
we gradually moved closer to our vision.
With the current release, we are proud to announce that Noux has become
obsolete without sacrificing its feature set! All use cases of Noux can now
be addressed by combining Genode's building blocks, in particular the
VFS server, VFS plugins for pipes and terminal access, the 'fs_rom' server,
and the C runtime.

[image from_noux_to_libc]

Figure [from_noux_to_libc] illustrates the different approaches. On the left,
the Noux runtime environment provides the traditional Unix system-call
interface to the Unix process(es), taking the position of a Unix kernel. Noux
implements concepts like a virtual file system, file descriptors, pipes, and
execve/fork. Structurally, it is very traditional.
The scenario on the right achieves the same functionality without a
Unix-kernel-like component. The VFS is provided by a standalone file-system
server. For obtaining executables from the VFS, the 'fs_rom' server is used.
The Unix program (bash in the example) is executed as a plain Genode component
that is linked against Genode's C runtime. This runtime transparently
implements fork/execve for spawning child processes (Vim in the example).
All inter-component communication is achieved via generic Genode session
interfaces like the file-system session. No Unix-like system call interface
between components is needed. The scenario on the right works on all kernels
supported by Genode, including Linux.

The retirement of Noux touches a lot of the existing system scenarios, which
had to be revisited one by one. Among the many examples and test cases updated
to the structure depicted above are _fs_query.run_, _ssh_terminal.run_,
_vim.run_, and _tool_chain_auto.run_. The latter is currently the most complex
scenario, which self-hosts the Genode tool chain and build/packaging system on
top of Genode.

Sculpt OS as the most prominent use case of Noux had to be adjusted as well.
The _noux-system_ package is now called _system_shell_. The log-noux instance
of the Leitzentrale has been replaced by a simple new component called
_stdin2out_. Disk-management operations are now performed by executing the
file-system utilities _e2fsck_, _resize2fs_, and _mke2fs_ as stand-alone
components. The prepare step and the inspect tab are realized as a system
composition like depicted above.


Removed components and features
===============================

RAM file-system server
~~~~~~~~~~~~~~~~~~~~~~

The 'ram_fs' file-system server has become obsolete because its feature
set is covered by the generic 'vfs' server when combined with the import VFS
plugin:

! <start name="ram_fs"...>
!   ...
!   <config>
!     <vfs>
!       <ram/>
!       <import>
!         ...
!       </import>
!     </vfs>
!     ...
!   </config>
! </start>

Since the VFS server is a full substitute, the current release drops the
original 'ram_fs' server.


Input-merger component
~~~~~~~~~~~~~~~~~~~~~~

The input-merger component was introduced in version
[https://genode.org/documentation/release-notes/14.11#New_input_merger - 14.11]
as a mechanism for merging PS/2 and USB HID input streams.
It was later superseded by the generic input filter in version
[https://genode.org/documentation/release-notes/17.02#Input-event_filter - 17.02].
The functionality of the input merger can be achieved with the input filter
using a configuration like this:

! <config>
!   <input label="ps2"/>
!   <input label="usb"/>
!   <output>
!     <merge>
!       <input name="ps2"/>
!       <input name="usb"/>
!     </merge>
!   </output>
! </config>

The current release removes the input merger.


OpenVPN moved to genode-world repository
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Since we do not consider our initial
[https://genode.org/documentation/release-notes/14.08#New_port_of_OpenVPN - port of OpenVPN]
as an officially supported feature of Genode, we moved it to Genode-world
repository.


Rust support removed
~~~~~~~~~~~~~~~~~~~~

Support for the Rust programming language was added as a community
[https://github.com/genodelabs/genode/pull/1899 - contribution] in 2016. It
included the ability to supplement Rust code to Genode components via Genode's
build system, a few runtime libraries, and a small test case. However, the
addition of Rust remained a one-off contribution with no consecutive
engagement of the developer. Over the years, we kept the feature alive - it
used to be exercised as part of our nightly tests - but it was never picked up
by any regular Genode developer. Once it eventually became stale, it was no
longer an attractive feature either because it depended on an outdated nightly
build of the Rust tool chain.

The current release removes Rust to lift our maintenance burden. To
accommodate Rust developers in the future, we may consider supporting Rust on
Genode via the [https://github.com/nfeske/goa - Goa] tool, and facilitating
regular tools and work flows like cargo.


Python2 removed
~~~~~~~~~~~~~~~

With Python3 present in the Genode world repository since version
[https://genode.org/documentation/release-notes/18.08#Python_3 - 18.08],
the time was overdue to remove our original port of Python2 from Genode's main
repository.


Init's ancient '<configfile>' feature removed
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The '<configfile>' feature of init allows the use of a ROM session for
obtaining the configuration for a started component. It has long been replaced
by the label-matching-based session routing.

! <route>
!   <service name="ROM" label_last="config">
!     <parent label="another.config"/> </service>
!   ...
! </route>

Since its naming is rather inconsistent with our terminology (ROM modules are
not files, the "name" is actually a "label") and its use case is covered by
init's generic session-routing mechanism, we took the chance to remove this
legacy with the current release.


Board support outside the Genode main repository
================================================

During the recent decade of development a wide range of hardware support entered
the Genode OS framework. However, the limited resources of a small
core-developer team at Genode Labs make it impossible to guarantee the same
daily test-coverage for every single board that entered the framework at some
point in time. On the other hand it is crucial for the acceptance of a project like
Genode to deliver high-quality and carefully tested components.

To balance the act in between keeping hardware support not necessarily
used by the core-team, and having thoroughly tested, recommended hardware
on the other hand, we decided to continously move hardware support not longer
tested regularily to the genode-world repository.

We started this process by abandon the OMAP4 and Exynos support to genode-world.
The support for Odroid X2 was skipped finally. Support for Odroid XU,
Arndale board, and Panda board on top of the base-hw kernel got moved to
genode-world. The Fiasco.OC kernel support for these boards is no longer
part of the framework.

If you like to build scenarios for one of the boards that are now located in
genode-world, you have to add the world repository to the 'REPOSITORIES'
variable of your build environment, e.g., by uncommenting the following line in
the 'etc/build.conf' file of your build directory:

! #REPOSITORIES += $(GENODE_DIR)/repos/world

To use the full convenience of using the run-tool with one of these
world-located boards, you have to tweak the location of the kernel's run-tool
plugin. Simply by replacing the following part:

! ifdef KERNEL
! RUN_OPT += --include boot_dir/$(KERNEL)
! endif

with the absolute path of the kernel-specific file in your genode-world
repository. Typically this would be:

! ifdef KERNEL
! RUN_OPT += --include $(GENODE_DIR)/repos/world/tool/run/boot_dir/$(KERNEL)
! endif

In the nearby future the following hardware targets will be moved to
genode-world too:

* nit6_solox
* usb_armory
* wand_quad
* zynq_qemu

For the community this step has the following advantages. Transparency is given
to you: all hardware support inside the main genode repositories gets tested all
night using the CI tools at Genode Labs. The targets inside genode-world are
only guaranteed to compile on a regular basis.
On the other hand the effort for contributors to introduce and maintain their
own hardware support is lowered, because the quality assurance with respect to
genode-world component is less strict.


Base framework and OS-level infrastructure
##########################################

New platform driver for the ARM universe
========================================

;@skalk

commit 337c20116d9782efccbca21f8aae36072f02de8c
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Wed Apr 22 17:55:18 2020 +0200

    os: refactor i.MX53 interactive drivers (ref #3299)
    
    * Remove input driver specific to i.MX53 tablet board from QSB driver pkg
    * Move GPIO settings for QSB LVDS backlight out of framebuffer driver into
      GPIO driver config
    * Move PWM driver functionality out of framebuffer driver
    * Make framebuffer driver configureable, and less dependent on
      platform driver i.MX53 specifics

commit b7aaeb58736b1df90902650f874718556e0289b6
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Thu May 14 15:28:46 2020 +0200

    Annotate io_mem session interface with RAM_QUOTA
    
    Ref #3299

commit 72c6f3aa159582612db06021759c7e6159397882
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Thu May 14 15:30:31 2020 +0200

    Annotate irq session interface with RAM_QUOTA
    
    Ref #3299

commit 2aa254119aa35b19a04c6639aa169d8bcc883d1c
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Fri May 22 12:47:16 2020 +0200

    usb_drv: include specific rpi platform_session API
    
    The rpi_usb_drv uses the rpi-specific variant of the platform_session API.
    Therefore, it has to include it excplicitly.
    
    Ref #3299

commit 1bb89ee3ee9710663a92efad0f5601bb87dea0b4
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Thu May 14 15:35:40 2020 +0200

    os: introduce common platform driver for ARM
    
    Ref #3299

commit a708972aff8ecaaffd16a06ffadc6e304bbae007
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Fri May 22 12:19:03 2020 +0200

    os: pl050, pl11x, lan9118 use ARM platform driver
    
    Make the framebuffer driver for pl11x chipsets,
    the ps2 input driver for pl050, and the lan9116 NIC driver independent from
    the pbxa9 board by using the newly introduced common ARM platform driver API.
    
    Ref #3299

Block-device sync operation support
===================================

Support for 'SYNC' block requests was extended through-out the block storage
stack. Such a request instructs the block components to flush their internal
buffers. Although it was already implemented in most prominent device drivers
such as AHCI and NVMe, we encountered problems with older AHCI controllers. A
'SYNC' request is now only issued when the NCQ queue of the AHCI controller is
empty.

In addition the block-VFS plugin as well as the 'lx_fs' file system component
now respect a sync request at VFS or rather file system session level.


Base API refinements
====================

Deprecation of unsafe 'Xml_node' methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One year ago, we
[https://genode.org/documentation/release-notes/19.02#Improved_API_safety - revised]
the interface of Genode's XML parser to promote memory safety.
The current release marks the risky API methods as deprecated and updates
all components to the modern API accordingly.


Replaced 'Genode::strncpy' by 'Genode::copy_cstring'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Since the first version of Genode, the public API features a few
POSIX-inspired string-handling functions, which were usually named after their
POSIX counterparts. In the case of 'strncpy', this is unfortunate because
Genode's version is not 100% compatible with the POSIX 'strncpy'. In
particular, Genode's version ensures the null-termination of the resulting
string as a mitigation against the most prevalent memory-safety risk of POSIX
'strncpy'. The current release replaces 'Genode::strncpy' with a new
'Genode::copy_cstring' function to avoid misconceptions caused by the naming
ambiguity in the future.


LOG session
~~~~~~~~~~~

The return value of 'Log_session::write' got removed. It was never meaningful
in practice but ignoring the value at the caller site tends to make static
code analyzers nervous.


Removed 'Allocator_guard'
~~~~~~~~~~~~~~~~~~~~~~~~~

The 'Allocator_guard' was an
[https://genode.org/documentation/release-notes/11.02#Comprehensive_accounting_of_core_resources - early]
take of a utility for tracking and constraining the consumption of memory
within a component. However, we later
[https://github.com/genodelabs/genode/issues/1039 - got aware] of several
limitations of the taken approach. In short, the 'Allocator_guard' tried
to attack the accounting problem at the wrong level of abstraction.
In Genode
[https://genode.org/documentation/release-notes/17.05#Merged_RAM_and_PD_services_of_the_core_component - 17.05],
we introduced a water-tight alternative in the form of the
'Constrained_ram_allocator', which was gradually being picked up be new
components. However, the relic from the past still remained present in several
time-tested components including Genode's core component. With the current
release, we finally removed the 'Allocator_guard' from the framework and
migrated all former users to the 'Constrained_ram_allocator'.

The adjustment of core in this respect has the side effect of a more accurate
capability accounting in core's CPU, TRACE, and RM services. In particular,
the dataspace capabilities needed for core-internal allocations via the
'Sliced_heap' are accounted to the client now. The same goes for nitpicker and
nic_dump as other former users of the allocator guard. Hence, the change
touches code at the client and server sides related to these services.


C runtime
=========

Decoupling C++ runtime support from Genode's base ABI
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Traditionally all Genode components are linked (explicitly or
implicitly) to the platform library and dynamic linker ld.lib.so. This
library provides the kernel-agnostic _base_ API/ABI and hides
platform-specific adaptations from the components. Also, ld.lib.so
includes the C++ runtime which is provided via the C++ ABI and
implements support for runtime type information, guard variables, and
exceptions. So, C++ programs using the named features are guaranteed
to work on Genode as expected.

Since the introduction of our
[https://genode.org/documentation/developer-resources/package_management - package management]
and depot archives in
[https://genode.org/documentation/release-notes/17.05#Package_management - release 17.05]
software packages are required to explicitly specify API dependencies.
For Genode components using the base framework, e.g., to implement
signal handlers in the entrypoint, the dependency to the _base_ API is
natural. Genode-agnostic programs using only the LibC or C++ STL on
the other hand shall not depend on one specific version of the
platform library. Unfortunately up to this release, this independence
could only be accomplished for C or simple C++ programs for the
reasons named before and all C++ components had to specify the
dependency to the base ABI. The unwanted result of this intermixture
was that complex POSIX programs (e.g., Qt5 applications) had to be
updated every time the base API changed in a tiny detail.

In this release, we cut the dependency on the LibC runtime level and
provide the C++ ABI symbols also to the LibC symbols. The
implementation of the functions remains in ld.lib.so and, thus, is
provided at runtime in any case. We also cleaned up many POSIX-level
depot archives from the base dependency already, which paves the way
less version updates in the future of only the base API changes.


Redirection of LOG output to TRACE events
=========================================

During the debugging of timing-sensitive system scenarios such as high-rate
interrupt handling of device drivers, instrumentations via the regular logging
mechanism becomes prohibitive because the costs of the logging skew the system
behavior too much.

For situations like this, Genode features a
[https://genode.org/documentation/release-notes/13.08#Light-weight_event_tracing - light-weight tracing]
mechanism, later supplemented with easy-to-use
[https://genode.org/documentation/release-notes/18.02#New_trace-logging_component - tooling].
Still, the tracing facility remains underused to this day.

As one particular barrier of use, manual instrumentations must explicitly
target the tracing mechanism by using the 'trace' function instead of the
'log' function. The process of switching from the logging approach to the
tracing mechanism is not seamless. The current release overcomes this obstacle
by extending the trace policy interface with a new policy hook of the form

! size_t log_output (char *dst, char const *log_message, size_t len);

The hook is invoked each time the traced component performs log output.
Once the trace monitor installs a trace policy that implements this hook
into the traced component, log output can be captured into the thread-local
trace buffer. The size of the captured data is returned. If the hook function
returns 0, the output is directed to the LOG as usual. This way, the
redirection policy of log output can even be changed while the component is
running!

The new feature is readily available for the use with the trace logger by
specifying the 'policy="log_output"' attribute at a '<policy>' node in the
trace logger's configuration. (excerpt taken from the example at
_os/recipes/pkg/test-trace_logger/runtime_):

! <config verbose="yes"
!         session_ram="10M"
!         session_parent_levels="1"
!         session_arg_buffer="64K"
!         period_sec="3"
!         activity="yes"
!         affinity="yes"
!         default_policy="null"
!         default_buffer="1K">
!
!   <policy label="init -> dynamic -> test-trace_logger -> dynamic_rom"
!           thread="ep"
!           buffer="8K"
!           policy="log_output"/>
! </config>

Thanks to Tomasz Gajewski for contributing this handy feature.


MSI-X support on x86
====================

The platform driver now supports to scan for the MSI-X cap of PCI devices
and to parse and setup the MSI-X structure to make use of it. With this
change MSI-X style interrupts are usable by kernels supporting MSI already.

The feature was tested with NVMe devices so far. If MSI-X is available for
a PCI devices, the output looks like this:

! [init -> platform_drv] nvme_drv -> : assignment of PCI device 01:00.0 succeeded
! [init -> platform_drv] 01:00.0 adjust IRQ as reported by ACPI: 11 -> 16
! [init -> platform_drv] 01:00.0 uses MSI-X vector 0x7f, address 0xfee00018
! [init -> nvme_drv] NVMe PCIe controller found (0x1987:0x5007)

Optimized retrieval of TRACE subject information
================================================

The trace infrastructure of Genode supports to track and to collect information
about the available subjects (e.g. threads) in the system. Up to now the retrival
of information about all subjects of count n required to make n RPC call to
Genode's 'core' component, which imply n times the overhead for process
context switching. With this release the trace session got extended to
request the subject infos of all subjects at once, in order to reduce the
overhead. The new 'for_each_subject_info' method of the trace client side
makes use of the new optimization and is used by the top component.

Library updates
===============

We updated the OpenSSL patch level from 1.0.2q to the latest version
1.0.2u as an intermediate step to a future update to 1.1.1.


Platforms
#########

Execution on bare hardware (base-hw)
====================================

Consolidated virtual machine monitor for ARMv7 and ARMv8
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The virtual machine monitor for ARMv8 introduced and enriched during the past
two releases got consolidated within this release cycle to support ARMv7 as
well. The old ARMv7 proof-of-concept implementation of the virtual machine
monitor is now replaced by it. Most code-base in between both architecture
variants is shared. Only certain aspects of the CPU model are differentitated.
As a positive side-effect the ARMv7 virtual machine is now supporting recent
Linux kernel versions too.

The virtualization support is still limited to the base-hw kernel. The ARMv7
variant can be used on the following boards:

* virt_qemu
* imx7d_sabre
* arndale (now in genode-world!)

The ARMv8 variant is now available on top of these boards:

* virt_qemu_64
* imx8q_evk


Write-combined framebuffer on x86
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Motivated by a chewy GUI performance of Sculpt on [https://genode.org/documentation/release-notes/20.02#Execution_on_bare_hardware__base-hw_ - Genode/Spunky], the write-
combining support for base-hw got enabled. To achieve better throughput
to the framebuffer memory, we set up the x86 page attribute table (PAT)
with a configuration for write combining and added the corresponding
cacheability attributes to the page-table entries of those framebuffer memory
mappings. With the changes the GUI feeling became more snappy.

Improved cache maintenance on ARM
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

While doing some performance measurements, when using a lot of
dataspaces, it became obvious that the usage of ARM cache maintainance
operations  was far from optimal in the base-hw kernel. As a consequence, we
consolidated all cache maintainance operations in the kernel across all ARM
processor variants. Thereby we also found some misunderstandings of the hardware
semantics related to making the instruction and data cache coherent. Which is
necessary when having self-modifying code in the Java JIT compiler for example.

Therefore, we also had to change the syscall interface for this pupose. The
now called 'cache_coherent_region' syscall is limited to only target
exactly one page at a time. However, the 'Genode::cache_coherent' function
of the base API abstracts away from these kernel-specific syscal anyway.

As another side-effect we tweaked the cleaning of memory. Whenever core hands
out a newly allocated dataspace its memory needs to be filled with zeroes to
prevent crosstalk of components. Now, the base-hw kernel contains architecture
specific ways of effectively cleaning memory, which dramatically increased the
performance for memory allocation intensive scenarios.


Qemu-virt platform support
~~~~~~~~~~~~~~~~~~~~~~~~~~

Thanks to the contribution of Piotr Tworek the base-hw kernel now runs on top
of the Qemu virt platform too. It comes in two flavours. The 32-bit 'virt_qemu'
board consists of 2GB of RAM, 2 Cortex A15 cores and uses the GICv2 interrupt
controller. The 'virt_qemu_64' board is the 64-bit variant with 4 Cortex A53
cores, a GICv3 interrupt controller, and has also 2GB of RAM.

Both machine models support the ARM virtualization extensions, which can be
utilized by using the Genode's virtual machine monitor for ARM, compare to
section [Consolidated virtual machine monitor for ARMv7 and ARMv8].


NOVA microhypervisor
====================

The CPU affinity handling concept of Genode got added with
[https://genode.org/documentation/release-notes/13.08#Management_of_CPU_affinities - release 13.08].
With this release we added support to leverage the two dimensional vision of
the concept, by grouping [https://en.wikipedia.org/wiki/Hyper-threading - hyper-threads]
of one Core on the y-axis in the affinity space of Genode.

Genode's 'core' roottask for NOVA got adjusted to scan the NOVA kernels hypervisor
information page (HIP) for the hyper-thread support. If available, all CPUs
belonging to the same core get grouped now in Genode's affinity space along
the y-axis. An example output on a machine with hyper-thread support now looks
like this:

! Hypervisor reports 4x2 CPUs
! mapping: affinity space -> kernel cpu id - package:core:thread
!  remap (0x0) -> 0 - 0:0:0) boot cpu
!  remap (0x1) -> 1 - 0:0:1)
!  remap (1x0) -> 2 - 0:1:0)
!  remap (1x1) -> 3 - 0:1:1)
!  remap (2x0) -> 4 - 0:2:0)
!  remap (2x1) -> 5 - 0:2:1)
!  remap (3x0) -> 6 - 0:3:0)
!  remap (3x1) -> 7 - 0:3:1)

From the output one can determine Genode's affinity notation in form of (x,y)
mapped to the correspending CPU. The package:core:thread column represents the
report by the NOVA kernel about CPU characteristics collected by utilizing
[https://en.wikipedia.org/wiki/CPUID - CPUID] during system boot up.

To utilize all hyper-threads in an init configuration, the affinity-space can
now be configured with a height of 2 and the y-axis of a 'start' node with 0
to 1, e.g.

! <config>
!  <affinity-space width="4" height="2"/>
!  ...
!  <start name="app">
!   <affinity xpos="0" ypos="1"/>  <!-- CPU on Core 0, Hyper-thread 1 -->
!   ...
!
!  <start name="app"> <!-- CPU on Core 3, Hyper-thread 0 -->
!   <affinity xpos="3" ypos="0"/>
!   ...
!  </start>
!
!  <start name="app"> <!-- CPU on Core 3, Hyper-thread 1 -->
!     <affinity xpos="3" ypos="1"/>
!   ...
!  </start>
! </config>

Note: With this new feature the former sorting of hyper-threaded
CPUs for Genode/NOVA is removed, which got introduced with [https://genode.org/documentation/release-notes/16.11#NOVA_hypervisor - release 16.08].
Previously, given a number of n logical CPUs (with hyper-threading enabled),
all hyper-threads with id 0 were available in the
affinity-space (x,y) from (0,0) to (n/2-1,0) and all
hyper-threads with id 1 as (n/2,0) to (n-1,0).


Linux
=====

When executed on top of the Linux kernel, Genode's core component used to
assume a practically infinite amount of RAM as the basis for the RAM-quota
trading within the Genode system. The current release introduces the option to
manually supply a realistic value of the total RAM quota as environment
variable to Genode's core component. If the environment variable
GENODE_RAM_QUOTA is defined, its value is taken as the number of bytes
assigned to the init component started by core.

Thanks to Pirmin Duss for this welcome contribution.
