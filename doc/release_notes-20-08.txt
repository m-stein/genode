

              ===============================================
              Release notes for the Genode OS Framework 20.08
              ===============================================

                               Genode Labs



;intro
;@nfeske


The GUI stack, restacked
########################


; high-level goals

; * future support of multi-head scenarios
; * support for screen capturing
; * resilience against failing device drivers
; * reducing the trusted computing base of graphical applications
; * starting, killing, and updating drivers at runtime without rebooting
; * improving the throughput of the pixel data path
; * optimizing input latency

; link to genodians article


Consistent naming
=================

The starting point of Genode's GUI stack was the nitpicker GUI server,
introduced in 2006 based on prior research of the Genode developers
([https://genode-labs.com/publications/nitpicker-secure-gui-2005.pdf - PDF]).
Back then, the name of the implementation proliferated throughout Genode at
the API level, over the configuration level, up to the naming of related
components. Jargon crept into the project without much thought. This had to
stop and now was the right time.

:Source tree:

  The _include/nitpicker_session_ headers moved to _include/gui_session_.
  Those headers are not tied to the specific nitpicker implementation but
  much more general. For example, the window manager provides an alternative
  implementation of the same interface.

  The change also affects the corresponding depot API archive accordingly.

:Configuration:

  The "Nitpicker" service is now called "Gui" service. The upper/lower casing
  follows the convention for services provided outside of Genode's core
  component.

:Packaged runtime definitions:

  The '<nitpicker>' nodes in runtime files are now named '<gui>'.

:API level:

  The C++ namespace 'Nitpicker' has been renamed to 'Gui'.

:Component names:

  The nit_fb server has become the gui_fb server.
  The nit_fader has become the gui_fader.


Streamlined pixel format
========================

Genode's framebuffer session interface was traditionally based on the RGB565
pixel format. We have now changed the format to 32-bit XRGB where the X part
is ignored. We updated all graphical applications and device drivers
accordingly.

This change also affects the users of the drivers_interactive packages. Now,
we generally assign 64 MiB RAM and 1500 caps to the drivers subsystem, which
is sufficient for covering high resolutions at 32 bits per pixel and to
accommodate multi-component USB HID input stacks.


New "Capture" and "Event" session interfaces
============================================

Traditionally, Genode's driver model for framebuffer and input drivers
followed a layered architecture. Each framebuffer driver naturally provided a
"Framebuffer" service and each user-input driver provided an "Input" service.
At the next layer, the nitpicker GUI server would use those services as a
client and, in turn, provide a higher-level "Nitpicker" service (which has now
been renamed to "Gui"). In this architecture, higher levels naturally depend
on all lower levels, specifically the framebuffer and input drivers at the
bottom.

This architecture is flawed because it makes the low-complexity GUI server
(nitpicker) depend on high-complexity and potentially flaky device drivers.
If a driver fails, the entire GUI stack - up to the applications - suffer.
To put the risk into perspective: The binary of the nitpicker GUI server
incorporates about 11,000 lines of code, which includes the Genode API
(the actual nitpicker code is about 3000 lines of plain C++).
In contrast, the intel framebuffer driver comprises more than 122,000 lines of
code (sloccount). We don't want nitpicker to depend on the intel framebuffer
driver. For input devices like USB HID, the situation looks very similar.

To solve this dilemma, we had to turn the client-server relationship between
the GUI server and the drivers upside down. This approach is enabled by two
new service interfaces. The new "Event" session replaces the former input
session. The new "Capture" session replaces the former framebuffer session.
The information that is flowing through those interfaces remains the same -
input events and pixels - but the direction is reversed. An event client
propagates input events to the server. A capture client obtains pixel data
from the server.

In the new architecture, nitpicker remains as the only server, providing
the "Event", "Capture", and "Gui" interfaces. It does no longer depend on the
well being of any driver. This is reflected by the <start> node of nitpicker
when integrating the GUI server into an init configuration:

! <provides>
!   <service name="Gui"/> <service name="Capture"/> <service name="Event"/>
! /provides>

To retain the support of cascaded usage scenarios of the GUI server,
nitpicker can be still instructed to request a framebuffer session or input
session by specifying the '<config>' attributes 'request_framebuffer="yes"'
and 'request_input="yes". If specified, nitpicker requests sessions to an
"Input" and a "Framebuffer" service upon startup and uses those as
input/output back end. Those services are usually provided by the gui_fb
component. Note that this facility may eventually be replaced by a
'request_gui' attribute (requesting a GUI session), eliminating the notion of
framebuffer and input services altogether.


Turning framebuffer drivers into capture clients
================================================

Following the introduction of the new capture-session interface,
we replaced the use of the "Framebuffer" session interface by
the new "Capture" session interface in all framebuffer drivers.
The new versions of all drivers had to be tested on the respective hardware.
Generally, the drivers have become simpler.

The drivers_interactive packages for various boards have changed their public
interface. The drivers subsystem no longer provides a "Framebuffer" service
but needs a valid route to the "Capture" service provided by nitpicker.
Of course, this change affected all run scripts that make use of nitpicker.


Turning input drivers into event clients
========================================

Analogously to the graphics drivers, all input drivers had to be reworked to
operate as event clients instead of input servers. This came down to adjusting
and testing the variety of PS/2 drivers and USB HID drivers on the various
platforms. Similar to the framebuffer drivers, this step generally made the
drivers simpler.


Replacing the input filter with an event filter
===============================================

The transition from the "Input" session to the "Event" session is not limited
to the drivers only but also affected Genode's input-filtering mechanism. The
functionality of the input_filter is now provided by the event_filter. The
event filter requests only one "Event" session as destination for the filter
result, which is usually routed to the nitpicker GUI server. It provides an
"Event" service to which any number of event sources can connect.

The configuration of the filter chain remains almost the same. Only the
declaration of the '<input>' nodes is no longer needed. Instead, the
configuration must specify '<policy>' nodes, which define the mapping of
"Event" clients (event sources) to the inputs used in the filter chain.


Improved Qt5 integration and work flows
#######################################

Streamlined build-system integration
====================================

Up to now, Qt libraries and applications for Genode had been built using the
Genode build system. The Qt library build files in the 'libports/lib/mk'
directory were in part generated with a shell script from the GNU make files
which the 'qmake' tool had generated when building Qt for Linux and there was
some rudimentary support for building Qt applications from qmake project files
by just interpreting the qmake project files as GNU make files and translating
the relevant qmake variables to corresponding Genode build system variables.

But this approach was not feasible anymore for building the 'qtwebengine'
module (the successor of the deprecated 'qtwebkit' module), which is based on
the Chromium web engine source code and mostly built with the Ninja build
system on the officially supported platforms instead of qmake.

We also want to make it easier for Genode users to build Qt applications, in
particular by using the 'goa' tool, so it would be better to be able to
actually process qmake project files with the qmake tool instead of
interpreting them as GNU make files and aborting when a project file contains
qmake-specific code not understood by GNU make.

For these reasons, we reworked the Qt build process so that it now uses qmake
with a tailored Genode platform configuration for building both Qt libraries
and applications.

If you had previously built a Qt application for Genode and want to continue
using it with the new release and you cannot use the goa tool yet (for
example because additional Qt libraries cannot be built with goa yet or because
other architectures than x86_64 are currently not supported by goa yet), you
need to update the 'target.mk' file (and any run scripts) of your project. For
the details, please have a look at the updated Qt example projects in the
'libports' repository and feel free to ask on the Genode mailing list if any
problems arise with the conversion. It is also necessary to rebuild the Qt
tool chain with the 'tool/tool_chain_qt5' script to get the qmake tool
built and installed.

While converting the run scripts of the Qt example projects, we switched to
using the 'drivers_interactive' package, which is the preferred way to start
drivers for interactive scenarios nowadays. A downside might be that network
or storage drivers are not loaded anymore this way. If these features are
needed for a Qt project, the suggested solution is to use goa or to run the
scenario with Sculpt OS instead, if possible.

Another Qt-related feature in this release is that the 'qt5_component' library
now extracts command line arguments and environment variables from the 'config'
ROM, like the 'posix' library already did for non-Qt applications.


Chromium engine and Falkon web brower
=====================================

Since the previously ported 'Arora' web browser has not been maintained
upstream for years and the 'qtwebkit' Qt module it depended on has also been
deprecated in the meantime, it was eventually time to try to port the newer
Chromium-based 'qtwebengine' module to Genode and to find a new maintained
qtwebengine-based web browser which can replace Arora. At first glance,
porting qtwebengine to Genode appeared to be quite a challenging task, since
officially only Linux, Windows and macOS are supported and most of the
qtwebengine code, which also contains a huge amount of third-party libraries,
is not built with qmake for the most part like other Qt modules, but with the
Ninja build system.

Fortunately, the situation turned out to be less problematic than expected, at
least with regard to the initial goal of getting a lightweight web browser
running and displaying regular web sites comparably to Arora. One reason for
that is that there already existed a qtwebengine port for FreeBSD, which
resolved most of the possible libc compatibility problems and thus served as
the basis for the Genode port. There were still some operating system specifics
in the code which had to be dealt with, though, like supporting shared memory
with 'mmap' or cache maintenance for JIT-compiled JavaScript code. Advanced web
engine features like multimedia support are disabled at the moment, also some
security-related features like the verification of server certificates
(requires a port of libnss), multi-processing or sandboxing.

The build system issue could eventually be resolved by adding a Genode platform
backend for qmake and passing the correct compiler options to the Chromium build
system.

As qtwebengine-based web browser we chose the [https://www.falkon.org - Falkon]
browser, which was previously known as 'QupZilla' and looks quite promising so far.


XXX screenshot


The Arora web browser and qtwebkit module are no longer available in this release.


Base framework and OS-level infrastructure
##########################################

Base API/ABI changes
====================

Synchronization primitives
~~~~~~~~~~~~~~~~~~~~~~~~~~

With the current release, we wrap up the
[https://genode.org/documentation/release-notes/20.05#Migration_from__Lock__to__Mutex__and__Blockade_ - migration]
of the code base from the 'Lock' to the 'Mutex' and 'Blockade' types to
improve diagnostics and clear the path towards future performance
optimizations.


Moved atexit handling from base library to C runtime
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Traditionally, Genode's base library took care of the execution of 'atexit'
handlers as this mechanism was regarded as fundamental to both C and C++.
In particular, the C++ compiler automatically generates calls to the
'__cxa_atexit' function of the C++ ABI for objects instantiated as local
static variables so that the destructors of such objects are called at the
exit of the program.

With the transition to Genode's modern component API (introduced in version
[https://genode.org/documentation/release-notes/16.05#New_component_API - 16.05]),
this mechanism became irrelevant for plain Genode components.
But for higher-level components that rely the C runtime, in particular POSIX
applications, this mechanism remained crucial. Hence, we did no question the
presence of the atexit mechanism in Genode's base library for a long time.

However, we ultimately realized that the atexit functionality must be
moved from the base library into the C runtime to fully adhere the
[https://genode.org/documentation/release-notes/17.02#New_execution_model_of_the_C_runtimed- execution model]
of the C runtime. Atexit handlers may perform I/O such as the closing and
syncing of files after all.

This change has the positive effect of reducing the complexity of the base
library. Furthermore, it overcomes the limitations of the formerly statically
dimensioned array of atexit handlers, which was wasteful for plain Genode
components, yet insufficient for complex POSIX applications.

Note that this change deliberately renders the atexit mechanism for plain
Genode components (without C runtime) ineffective. Genode components that used
to rely on the 'genode_exit' function for calling cleanup code must be changed
to explicitly call cleanup code.

This change also removes the implicit call of 'genode_exit(1)' by 'abort',
which is triggered by, i.e., uncaught exceptions. Scenarios that relied on
the former behavior for component monitoring should be changed to use
[https://genode.org/documentation/release-notes/18.11#Component_health_monitoring - heartbeat monitoring]
mechanism instead.

As another minor but still noteworthy detail, shared-library destructors are
no longer called via the atexit mechanism by explicitly by the dynamic linker.
This slightly changes the call order of destructors: Functions marked as
destructors are called after the libc-managed atexit handlers now.


Removal of deprecated interfaces
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Unsafe 'Xml_node' methods
-------------------------

The unsafe 'Xml_node' methods marked as deprecated in the
[https://genode.org/documentation/release-notes/20.05#Deprecation_of_unsafe__Xml_node__methods - previous release]
have been removed now.


Cancel-blocking interface
-------------------------

Closely related to the revised synchronization primitives mentioned above,
we removed the outdated 'Cancelable_lock' API along with the
underlying cancel-blocking mechanism, which had became obsolete by now. In
past times, this mechanism was employed to cleanly wind down threads that are
blocked at their destruction time. The move of Genode's API design away from
blocking RPC to asynchronously working components marginalized the problem to
the point where it ceased to exist.


Delayed dispatch of 'Rpc_entrypoint'
------------------------------------

Similar to the cancel-blocking mechanism, the ability to delay the dispatching
of RPC requests until an explicit call of 'Rpc_entrypoint::activate' is an API
relic from a time when each RPC server was multi-threaded. The modern flow of
execution has become much simpler, eliminating the need for this feature.


C runtime
=========

Serialized VFS access
~~~~~~~~~~~~~~~~~~~~~

Unsurprisingly, the VFS is an integral part of the C runtime as
_everything is a file_ in the UNIX philosophy. The basis for the libc
VFS is the VFS library and its versatile plugin concept. As the libc
(and other users of the library) may employ multiple threads, which
could use the VFS, the integrity of data structures esp. those of more
complex plugins like the network stack in _vfs_lwip_ must be protected
from concurrent access. From the beginning, we planned to move the
serialization of accesses out of the plugins into code the uses the
VFS library but missed to completely achieve this goal with the libc
execution model. With Genode 20.08, we transformed the lower parts of
the libc into an execution monitor that ensures the aspired serialized
processing of VFS operations. This paves the way to the removal of
synchronization measures in all VFS plugins in the upcoming release.

Removal of libc_pipe LibC plugin
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The VFS pipe plugin was introduced in
[https://genode.org/documentation/release-notes/19.11#VFS_plugin_for_emulating_POSIX_pipes - Genode 19.11]
and matured into a suitable replacement for the aged libc_pipe plugin
library. Now, we finalize this process by removing the old libc plugin
from Genode and all run scripts (most prominently those for Qt5
examples). Users can migrate to the VFS plugin with the following
changes to their component configurations.

* The libc must be configured to access the pipe mechanism from a VFS
  path by the 'pipe="..."' configuration attribute like follows.
  ! <libc ... pipe="/pipe"/>
* The pipe plugin must be instantiated in the VFS at the desired path.
  ! <vfs>...
  !  <dir name="pipe"> <pipe/> </dir>
  ! </vfs>
* Runs scripts no longer need to integrate _libc_pipe.lib.so_ into the
  boot modules but _vfs_pipe.lib.so_.

Placing pthreads on CPUs
~~~~~~~~~~~~~~~~~~~~~~~~

Up to now, pthreads experienced no affinity configuration on creation
time and ran implicitly on the first CPU available to the component
only. With this release, we add a placement strategy and configuration
option to the C runtime to enable the tuning of CPU placement for
pthreads of libc components. The default placement strategy is
'all-cpus', which means pthreads are assigned to the available CPUs.
round-robin.

The new '<pthread placement="manual">' libc configuration sub-node can
be used to manually place pthreads according to their 'id' on 'cpu' as
follows.

! <config>
!   <libc ...>
!     <pthread placement="manual">
!     .   <thread id="0" cpu="0"/> <!-- pthread.0 placed on CPU 0 -->
!     .   <thread id="1" cpu="1"/> <!-- pthread.1 placed on CPU 1 -->
!     .   <thread id="2" cpu="2"/> <!-- pthread.2 placed on CPU 2 -->
!     .   <thread id="3" cpu="2"/> <!-- pthread.3 placed on CPU 2 -->
!     </pthread>
!  </libc>

Note, the current placement-strategy implementation is limited to 32
pthreads. If more pthreads are running simultaneously further threads
are placed on CPU 0.


Standard C++ library
====================

We enabled support for thread-related features like 'std::thread' or
'std::mutex' in the stdcxx library.


Ada/SPARK support
=================

With the development of the [Consistent Block Encrypter], Genodes Ada/SPARK
support was used in the context of a more complex software project for the
first time. Therefore, we felt the necessity to make up our minds about a
generally accepted Ada/SPARK coding-style as long as this step still doesn't
entail the painstaking adaption of large amounts of code.

Fortunately, the GNAT compiler flags assist developers a lot in this affair.
That said, we added the consideration of two new environment Make-variables to
the Genode toolchain: 'CC_ADA_WARN' and 'CC_ADA_WARN_STRICT'. Analogously to
the C++ pendants ('CC_CXX_WARN' and 'CC_CXX_WARN_STRICT'), the variable
'CC_ADA_WARN' denotes the common warning-configuration of the compiler for
Ada/SPARK while 'CC_ADA_WARN_STRICT' by default applies additional
configuration for a much higher level of strictness. This strict mode might be
deactivated locally for code which isn't subject to the Genode coding style -
e.g. ported third party code - by adding 'CC_ADA_WARN_STRICT = ' to the
corresponding Make files.

The common warning configuration for Ada/SPARK merely enables all warning
messages with the '-wa' flag. As with C++, the strict mode furthermore causes
GNAT to treat warnings like errors and refrain from compiling affected
Ada/SPARK code. In addition to that, the strict mode releases a broad variety
of checks for potential pitfalls and style consistency using the configuration
'-gnatyyBdSux' (which is compatible to the GNAT standard style). A
comprehensive description of all checks activated by this configuration would
be beyond the scope of this document. So, please have a look at the
[https://gcc.gnu.org/onlinedocs/gnat_ugn/Style-Checking.html - GNAT style-checking reference]
instead if you're interested.

Besides the style enforced through compiler flags, we decided to generally
promote "Camel-Snake Casing" for Ada/SPARK code. The only exceptions from that
form abbreviations of initials that are completely upper case and language
keywords that are completey lower case. This would be a conform snippet of
code:

! function T1_Node_XML_Tag_Open (
!    Node     : Type_1_Node_Type;
!    Node_Idx : Type_1_Node_Block_Index_Type;
!    Show_Hsh : Boolean;
!    VBA      : Virtual_Block_Address_Type)
! return String;

Another minor improvement of Genodes Ada/SPARK runtime consists in the
added support for the exponential operator on integers.


Operating-system components
###########################

Consistent Block Encrypter
==========================

With the Genode 20.05 release, our
[https://genode.org/documentation/release-notes/20.05#Feature-completeness_of_the_consistent_block_encrypter - Constistent Block Encrypter (CBE) reached feature completeness]
adding support for
[https://genodians.org/m-stein/2020-06-07-cbe-rekeying - online rekeying]
and
[https://genodians.org/m-stein/2020-06-08-cbe-resizing - online resizing].
Furthermore, we were able to run a Linux virtual machine using a CBE device as
system partition. During the last three months, we mainly reviewed and
consolidated the code but also improved the integration in a notable way.

One important step forward is that we implemented a new _reference_ Trust
Anchor. The Trust Anchor (TA) is a separate entity (might be a smartcard, a USB
dongle, or a piece of software) that the CBE relies on for key management and
for storing superblock hashes. In contrast to the dummy TA we used for testing
so far, the reference TA stores private key and superblock hashes persistently
through a file-system back-end and requires the user to enter a passphrase to
be unlocked. This enables the CBE to actually verify that the CBE device is in
the same state that it was left in the last time and that only authorized users
can access its data.

Furthermore, both the Crypto and the TA back end of the CBE are now integrated
through VFS plugins. This change gives the user of the CBE more flexibility in
two ways. On one hand, he can switch between integrating those entities locally
(inside the CBE driver) or remotely (in a VFS server instance isolated from
the CBE driver) by merely altering the system configuration.

[image cbe_integration - Three different ways to integrate the CBE]

On the other hand, the implementation of the Crypto entity and the Trust
Anchor can now be switched through means of configuration alone. For instance,
let us take a look at the VFS server in the CBE test scenario
'repos/cbe/run/vfs_cbe.run':

! <start name="vfs_cbe" caps="120">
!   <config>
!     <vfs>
!       <cbe_crypto_aes_cbc name="cbe_crypto"/>
!       ...
!     </vfs>
!     ...
!   </config>
!   ...
! </start>

We may replace the plugin employing an AES-CBC ESSIV block-cipher in this test
with one using plain memcopy (in other words: disabling block encryption) by
changing only one line:

! <start name="vfs_cbe" caps="120">
!   <config>
!     <vfs>
!       <cbe_crypto_memcopy name="cbe_crypto"/>
!       ...
!     </vfs>
!     ...
!   </config>
!   ...
! </start>

The memcopy example may in fact be useful for contexts where only the abilities
of the CBE to manage snapshots and to ensure consistency are of interest and
encryption would only generate unnecessary overhead. However, the main
motivation behind this is to allow for an easy application of other cipher
algorithms.

In order to make things even more approachable, the VFS-plugin-related code
between CBE, Crypto entity, and Trust Anchor relies on generic interfaces.
This simplifies supporting other existing cryptographic algorithms and TA
types as enabling them boils down to solely implementing a handfull of well
defined hook functions.

As for the CBE demo scenario that we published with the last Genode release:
The corresponding packages moved from the package source 'cnuke' to 'mstein'.
Furthermore, the CBE demo is now based on the unaltered Genode master branch
and the new master branch in the CBE repository itself. Besides that, for the
most part, the procedure for reproducing the demo described in the
[https://genodians.org/m-stein/2020-06-12-cbe-linux-vm - demo article] and the
[https://genodians.org/m-stein/2020-06-17-cbe-linux-vm-video - demo video] remained
the same. But be prepared to find minor discrepancies.


Virtual file system (VFS)
=========================

We extended the 'zero' VFS plugin to limit the amount of data, e.g., 0s,
it will provide. By setting the 'size' attribute a reader is restricted to
only consume data up to the specified amount per VFS handle. Through that
is serves as natural EOF. The attribute is parsed as 'Number_of_bytes', which
caps the amount to the maximum of the addressable memory on the platform.

This addition comes in handy when needing to provide a synthetic empty file
with a fixed size:

! <vfs>
!   <ram/>
!   <import>
!     <zero name="block_file" size="32M"/>
!   </import>
! </vfs>


Furthermore, we added an option the 'terminal' VFS plugin to ignore control
characters. Usually this plugin is used in interactive configurations where
reacting to control characters, e.g. ^C, is vital. That being said, the plugin
lends itself as general transport mechanism for low-traffic data transfers.
Those transfers, however, may contain arbitrary data that could very well be
interpreted as control characters. Therefor, we introduced the 'raw'
configuration attribute. Setting the attribute instructs the plugin to pass
all data through as-is without further interpretation.

! <vfs>
!   <dir name="/dev">
!     <terminal name="io" raw="yes"/>
!   </dir>
! </vfs>


Block server backed by VFS content
==================================

This release adds a new component that provides access to a VFS file
through a Block session. Block requests will be translated to VFS requests
operating directly on the file.

The client access is configured by setting the attributes of the 'policy'
node appropriately. The assumed block size of the underlying file must be
specified via the 'block_size' attribute. It defaults to 512 bytes.

The block count is determined by querying the file and dividing its size by
the block size. Pseudo file systems which do not return a proper size in their
'stat' implementation will therefore not work. The 'writeable' attribute
denotes if the Block session is allowed to perform write requests. However,
if the underlying file is read-only such requests will nonetheless
fail. The default value is 'no'.

The following snippets shows a configuration where the 'vfs_block' component
allows the component 'the_client' writeable access to the 'ext2_disk.img'
file. In return, this file is accessed via a file-system session.

! <start name="vfs_block">
!   <resource name="RAM" quantum="3M"/>
!    <provides> <service name="Block"/> </provides>
!      <config>
!
!        <vfs>
!          <fs buffer_size="2M" label="backend"/>
!        </vfs>
!
!        <policy label="the_client" file="/ext2_disk.img" block_size="512"
!                writeable="yes"/>
!      </config>
!      <route>
!        <service name="File_system" label="backend>
!          <child name="fs_provider"/> </service>
!        <any-service> <parent/> </any-service>
!      </route>
! </start>

As the 'vfs_block' is by using the VFS library flexible enough to cover the
use-cases of components like 'ram_block' and 'rom_block' we decided to remove
them.

For example a typical 'rom_block' use-case is implemented by using this
configuration:

! <start name="vfs_block">
!   <resource name="RAM" quantum="2M"/>
!    <provides> <service name="Block"/> </provides>
!      <config>
!
!        <vfs>
!          <rom name="genode.iso"/>
!        </vfs>
!
!        <default-policy file="/genode.iso" block_size="2048"/>
!      </config>
!      <route>
!        <any-service> <parent/> </any-service>
!      </route>
! </start>

On a technical note, the server currently only allows for one active session
and manages only one pending back end request but can easily be extended in the
future.


Device drivers
##############

System management privilege
===========================

The PD session interface of the base library got extended by a system management
call:

! Managing_system_state managing_system(Managing_system_state const & state)

It is used to call privileged system management functionality, like power
management or clock settings that cannot be implemented in user-land components.
The transfered state is equivalent to the common, general-purpose cpu registers.
Currently, the function is implemented by the base-hw's core component on ARMv8
to call the ARM Trusted Firmware on behalf of the PD session client. All other
kernel and architectures leave the `managing_system` call empty.

A special privilege is necessary to enable a component to use the new call.
Therefore, the init component's configuration provides a new attribute
in the start node:

! <start name="platform_drv" managing_system="yes">
!   ...

The new call and privilege got introduced to enable a platform driver to
implement power management on modern ARM SoC.

The formerly existent, special privilege "constrain_phys", which was used by the
platform driver to constrain physical memory to be allocated for DMA to a
specific region, is now implicit part of the "managing_system" privilege.


Platform driver
===============

Configuration changes
~~~~~~~~~~~~~~~~~~~~~

The new platform driver API that was introduced with the last release for the
ARM architecture gets a minor subsequent improvement. The device resource
description within the configuration of the platform driver:

! <device name"foo">
!   <resource name="IRQ"    ... />
!   <resource name="IO_MEM" ... />
! </device>

is now shortened to the following:

! <device name="foo">
!   <irq    ... />
!   <io_mem ... />
! </device>

Power and clocks for i.MX 8M Quad SoC
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To drive peripherals of the i.MX 8M Quad Evaluation Kit and the MNT Reform 2
accordingly, we introduce a new platform driver specific for the i.MX 8M Quad
SoC used by both platforms.

The new driver implements the same API, like the generic ARM platform driver
introduced in release 20.05, but adds power-, and clock-management specific to
this SoC in addition. It comprises all power and clock settings available in the
SoC. Single power-domains and clocks can be assigned to devices. When the
client of the platform driver acquires a device, its power-domains and clocks
are enabled implicitely, and all clocks are set accordingly. When the device
gets released again, all power-domains and clocks are disabled again.

The following USB host controller example for the i.MX 8M Quad EVK illustrates
the additional configuration options:

! <device name="usb_host_2">
!   <io_mem       address="0x38200000" size="0x10000"/>
!   <irq          number="73"/>
!   <power-domain name="usb_otg_2"/>
!   <clock        name="usb_phy_ref_clk_root"
!                 driver_name="usb_phy_root_clk"
!                 parent="system_pll1_div8"
!                 rate="100000000"/>
!   <clock        name="usb_core_ref_clk_root"
!                 parent="system_pll1_div8"
!                 rate="100000000"/>
!   <clock        name="usb_bus_clk_root"
!                 parent="system_pll2_div2"
!                 rate="500000000"/>
!   <clock        name="usb_ctrl2_gate"/>
!   <clock        name="usb_phy2_gate"/>
!   <property     name="compatible" value="snps,dwc3"/>
!   <property     name="dr_mode" value="host"/>
! </device>

Most clock settings can be derived directly by looking at device tree sources
for the corresponding board and peripheral, e.g., in the Linux kernel tree. But
be aware that the clock names are aligned to the i.MX 8M Quad Applications
Processors Reference Manual and not the Linux code.

New platform driver for Raspberry Pi
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As some driver components like the USB host controller driver share one code
base across a lot of different boards, SoCs, and architectures. We like to unify
the API they are dependent on, including the platform driver's API. Therefore,
the already existent platform driver for Raspberry Pi 1 got modernized to use
the new platform driver API for ARM introduced with the last release.

However, we did not achieve to change all drivers at once. Therefore, we kept
the old platform driver still used by some drivers for now. To prevent
name clashes, the new driver is named "rpi_new_platform_drv" until the legacy
driver "rpi_platform_drv" vanishs.

During this work, we unified the former different enumeration of interrupts in
between Fiasco.OC and base-hw.

USB host controller driver
==========================

The USB host controller driver got modified to iterate over all device resources
the platform driver provides to it, and register those in corresponding Linux
kernel structures of the ported driver code. This board-specific information was
hard-coded beforehand. Now, the driver uses the platform driver for x86, as well
as all ARM architectures.

Interactive drivers support for Arndale and Panda boards
========================================================

In the Genode world repository the almost abandoned support for Pandaboard and the
Arndale board got revived by drivers_interactive depot packages for both.
Therewith, it is now easy again to use interactive run-script scenarios on these
platforms.

Libraries and applications
##########################

Migration of ported software to Genode-World
============================================

In the previous releases, we continuously relieved the Genode main repository
from features that receive no continuous maintenance. Rather than dropping
such features, they find a new home at the
[https://github.com/genodelabs/genode-world - Genode-World] repository.
We foster this distinction to avoid wrong expectations. Whereas the code of
the Genode main repository is subjected to rigid quality assurance at Genode
Labs, the content of the World repository is tested and maintained in a rather
ad-hoc fashion.

The current release moves the Solo5 runtime (originally added in version
[https://genode.org/documentation/release-notes/18.11#Genode_as_a_platform_for_Mirage-OS_unikernels - 18.11])
and the stubby DNS tool to the Genode-World repository.


New ported 3rd-party software in Genode-World
=============================================

Port of SDL 2.0.14
------------------

As more and more software requires SDL2 it became necessary to support it
as well in addition to the already existing support for SDL1. We therefore
ported the upcoming version to Genode.

For the time being its functionality is limited in constrast to the SDL1
port - only input and unaccelerated video is supported - but will be extended
in the future to also cover the other subsystems.

Even in its limited state it is plenty as it allows for
[https://www.genodians.org/alex-ab/2020-07-02-scrcpy - Streaming Android to Genode using Scrcpy].

Port of iperf2
--------------

;@rolandbaer

commit 48b76d1d6d0889347be5e08bab8832175c15f561
Author: rolandbaer <rbaer@gmx.ch>
Date:   Sat Aug 8 00:03:21 2020 +0200

    Port of iperf2
    
    The run script is based on the netperf run scripts.
    
    Fixes #221

Port of gRPC
------------

_This work is a contribution by Pirmin Duss of_
_[https://gapfruit.com - Gapfruit]. Thanks for this welcome update._

At gapfruit, we wanted to provide an efficient way to combine a Genode system with
existing cloud environments. For that we ported the gRPC/protobuf libraries
and tool chain to Genode. For this release, we simplified the tool chain so
it does not depend on any packages of your Linux distribution.
Additionally, we fixed a memory leak and updated the port to gRPC
version 1.28.1 and protobuf version 3.11.2.


Removal of orphaned 3rd-party ports
===================================

The dde_zircon device-driver environment was added in
[https://genode.org/documentation/release-notes/18.08#Experimental_runtime_for_Zircon-based_drivers - 18.08]
as an experiment for executing device drivers of Google's Fuchsia OS as Genode
components. However, since the initial import of the feature, it remained
unused and received no further development. As Fuchsia largely diverged from
the APIs implemented by dde_zircon in the meantime, we decided to remove the
feature.


Sculpt OS improvements
######################

The Genode-based [https://genode.org/download/sculpt - Sculpt] operating
system has been updated to the new Genode version without major user-visible
changes. Given the fact that this release turned the low-level GUI stack
upside down (Section [The GUI stack, restacked]), this must be read as *good*
news. The GUI-stack changes have several nice side effects:

* The elimination of color-space conversions in the pixel-data path has
  noticeably improved the interactive latency. Sculpt OS has never been
  as snappy as now.

* As Sculpt's base system no longer depends on the successful initialization
  of the framebuffer and user-input devices, the administrative user interface
  can be started even before the low-level drivers are ready, increasing the
  parallelism at boot time. Yes, Sculpt OS boots even faster now.

* The now ubiquitous use of 32-bit pixels throughout the whole GUI stack has
  largely eliminated the need for dithering, thereby improving the visual
  clarity of the user interface. Dithering remains in use in some situations
  though. In particular to reduce quantization artifacts for the alpha channel
  of the leitzentrale overlay.


Interactive CPU affinity configuration
--------------------------------------

The component-configuration dialog gained the new ability to restrict the
component to a subset of CPUs. This option is available under the "Resource
assignment" sub menu.

[image sculpt_affinity]

The configuration dialog shows a matrix of CPU cores whereas the X axis
denotes the physical cores and the Y axis the hyperthreads. By default, all
available CPU cores are selected. The user can toggle the nodes by clicking on
them. The dialog ensures that the selection is always a rectangular area. So
one click may affect nodes other than only the clicked one.


Fail-safe handling of unsupported partition tables
--------------------------------------------------

Sculpt now uses Genode's heartbeat-monitoring mechanism to detect the failure
of part_block instances during storage discovery. This situation can happen
whenever a storage device contains an unsupported partitioning-table format.
In this case or other error cases, the discovery would fail to complete. The
new version of Sculpt responds to this situation by removing the unresponsive
part_block instance automatically, releasing the corresponding device. This
leaves the device available for alternative uses, for example assigning it to
a virtual machine.


Platforms
#########

Execution on bare hardware (base-hw)
====================================

;@skalk

commit 04d8c859d8dc191d0919277a7d4dbb720ace0bf0
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Wed Jun 17 15:23:31 2020 +0200

    hw: enable branch predictor on rpi
    
    * Z-bit was never enabled for rpi1
    * Write buffer, and TCM bits are deprecated in this processor generation
      so do not use them
    
    Ref #3247

commit 1f91fd3f7de7e07ffb564849c0061ca21eb2a418
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Thu Jun 25 11:24:24 2020 +0200

    hw: scale imx8q_evk cpu to 1.5 GHz

