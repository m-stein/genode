

              ===============================================
              Release notes for the Genode OS Framework 20.08
              ===============================================

                               Genode Labs



;intro
;@nfeske


The GUI stack, restacked
########################


; high-level goals

; * future support of multi-head scenarios
; * support for screen capturing
; * resilience against failing device drivers
; * reducing the trusted computing base of graphical applications
; * starting, killing, and updating drivers at runtime without rebooting
; * improving the throughput of the pixel data path
; * optimizing input latency

; link to genodians article


Consistent naming
=================

The starting point of Genode's GUI stack was the nitpicker GUI server,
introduced in 2006 based on prior research of the Genode developers
([https://genode-labs.com/publications/nitpicker-secure-gui-2005.pdf - PDF]).
Back then, the name of the implementation proliferated throughout Genode at
the API level, over the configuration level, up to the naming of related
components. Jargon crept into the project without much thought. This had to
stop and now was the right time.

:Source tree:

  The _include/nitpicker_session_ headers moved to _include/gui_session_.
  Those headers are not tied to the specific nitpicker implementation but
  much more general. For example, the window manager provides an alternative
  implementation of the same interface.

  The change also affects the corresponding depot API archive accordingly.

:Configuration:

  The "Nitpicker" service is now called "Gui" service. The upper/lower casing
  follows the convention for services provided outside of Genode's core
  component.

:Packaged runtime definitions:

  The '<nitpicker>' nodes in runtime files are now named '<gui>'.

:API level:

  The C++ namespace 'Nitpicker' has been renamed to 'Gui'.

:Component names:

  The nit_fb server has become the gui_fb server.
  The nit_fader has become the gui_fader.


Streamlined pixel format
========================

Genode's framebuffer session interface was traditionally based on the RGB565
pixel format. We have now changed the format to 32-bit XRGB where the X part
is ignored. We updated all graphical applications and device drivers
accordingly.

This change also affects the users of the drivers_interactive packages. Now,
we generally assign 64 MiB RAM and 1500 caps to the drivers subsystem, which
is sufficient for covering high resolutions at 32 bits per pixel and to
accommodate multi-component USB HID input stacks.


New "Capture" and "Event" session interfaces
============================================

Traditionally, Genode's driver model for framebuffer and input drivers
followed a layered architecture. Each framebuffer driver naturally provided a
"Framebuffer" service and each user-input driver provided an "Input" service.
At the next layer, the nitpicker GUI server would use those services as a
client and, in turn, provide a higher-level "Nitpicker" service (which has now
been renamed to "Gui"). In this architecture, higher levels naturally depend
on all lower levels, specifically the framebuffer and input drivers at the
bottom.

This architecture is flawed because it makes the low-complexity GUI server
(nitpicker) depend on high-complexity and potentially flaky device drivers.
If a driver fails, the entire GUI stack - up to the applications - suffer.
To put the risk into perspective: The binary of the nitpicker GUI server
incorporates about 11,000 lines of code, which includes the Genode API
(the actual nitpicker code is about 3000 lines of plain C++).
In contrast, the intel framebuffer driver comprises more than 122,000 lines of
code (sloccount). We don't want nitpicker to depend on the intel framebuffer
driver. For input devices like USB HID, the situation looks very similar.

To solve this dilemma, we had to turn the client-server relationship between
the GUI server and the drivers upside down. This approach is enabled by two
new service interfaces. The new "Event" session replaces the former input
session. The new "Capture" session replaces the former framebuffer session.
The information that is flowing through those interfaces remains the same -
input events and pixels - but the direction is reversed. An event client
propagates input events to the server. A capture client obtains pixel data
from the server.

In the new architecture, nitpicker remains as the only server, providing
the "Event", "Capture", and "Gui" interfaces. It does no longer depend on the
well being of any driver. This is reflected by the <start> node of nitpicker
when integrating the GUI server into an init configuration:

! <provides>
!   <service name="Gui"/> <service name="Capture"/> <service name="Event"/>
! /provides>

To retain the support of cascaded usage scenarios of the GUI server,
nitpicker can be still instructed to request a framebuffer session or input
session by specifying the '<config>' attributes 'request_framebuffer="yes"'
and 'request_input="yes". If specified, nitpicker requests sessions to an
"Input" and a "Framebuffer" service upon startup and uses those as
input/output back end. Those services are usually provided by the gui_fb
component. Note that this facility may eventually be replaced by a
'request_gui' attribute (requesting a GUI session), eliminating the notion of
framebuffer and input services altogether.


Turning framebuffer drivers into capture clients
================================================

Following the introduction of the new capture-session interface,
we replaced the use of the "Framebuffer" session interface by
the new "Capture" session interface in all framebuffer drivers.
The new versions of all drivers had to be tested on the respective hardware.
Generally, the drivers have become simpler.

The drivers_interactive packages for various boards have changed their public
interface. The drivers subsystem no longer provides a "Framebuffer" service
but needs a valid route to the "Capture" service provided by nitpicker.
Of course, this change affected all run scripts that make use of nitpicker.


Turning input drivers into event clients
========================================

Analogously to the graphics drivers, all input drivers had to be reworked to
operate as event clients instead of input servers. This came down to adjusting
and testing the variety of PS/2 drivers and USB HID drivers on the various
platforms. Similar to the framebuffer drivers, this step generally made the
drivers simpler.


Replacing the input filter with an event filter
===============================================

The transition from the "Input" session to the "Event" session is not limited
to the drivers only but also affected Genode's input-filtering mechanism. The
functionality of the input_filter is now provided by the event_filter. The
event filter requests only one "Event" session as destination for the filter
result, which is usually routed to the nitpicker GUI server. It provides an
"Event" service to which any number of event sources can connect.

The configuration of the filter chain remains almost the same. Only the
declaration of the '<input>' nodes is no longer needed. Instead, the
configuration must specify '<policy>' nodes, which define the mapping of
"Event" clients (event sources) to the inputs used in the filter chain.


Improved Qt5 integration and work flows
#######################################

Streamlined build-system integration
====================================

Up to now, Qt libraries and applications for Genode had been built using the
Genode build system. The Qt library build files in the 'libports/lib/mk'
directory were in part generated with a shell script from the GNU make files
which the 'qmake' tool had generated when building Qt for Linux and there was
some rudimentary support for building Qt applications from qmake project files
by just interpreting the qmake project files as GNU make files and translating
the relevant qmake variables to corresponding Genode build system variables.

But this approach was not feasible anymore for building the 'qtwebengine'
module (the successor of the deprecated 'qtwebkit' module), which is based on
the Chromium web engine source code and mostly built with the Ninja build
system on the officially supported platforms instead of qmake.

We also want to make it easier for Genode users to build Qt applications, in
particular by using the 'goa' tool, so it would be better to be able to
actually process qmake project files with the qmake tool instead of
interpreting them as GNU make files and aborting when a project file contains
qmake-specific code not understood by GNU make.

For these reasons, we reworked the Qt build process so that it now uses qmake
with a tailored Genode platform configuration for building both Qt libraries
and applications.

If you had previously built a Qt application for Genode and want to continue
using it with the new release and you cannot use the goa tool yet (for
example because additional Qt libraries cannot be built with goa yet or because
other architectures than x86_64 are currently not supported by goa yet), you
need to update the 'target.mk' file (and any run scripts) of your project. For
the details, please have a look at the updated Qt example projects in the
'libports' repository and feel free to ask on the Genode mailing list if any
problems arise with the conversion. It is also necessary to rebuild the Qt
tool chain with the 'tool/tool_chain_qt5' script to get the qmake tool
built and installed.

While converting the run scripts of the Qt example projects, we switched to
using the 'drivers_interactive' package, which is the preferred way to start
drivers for interactive scenarios nowadays. A downside might be that network
or storage drivers are not loaded anymore this way. If these features are
needed for a Qt project, the suggested solution is to use goa or to run the
scenario with Sculpt OS instead, if possible.

Another Qt-related feature in this release is that the 'qt5_component' library
now extracts command line arguments and environment variables from the 'config'
ROM, like the 'posix' library already did for non-Qt applications.


Chromium engine and Falkon web brower
=====================================

Since the previously ported 'Arora' web browser has not been maintained
upstream for years and the 'qtwebkit' Qt module it depended on has also been
deprecated in the meantime, it was eventually time to try to port the newer
Chromium-based 'qtwebengine' module to Genode and to find a new maintained
qtwebengine-based web browser which can replace Arora. At first glance,
porting qtwebengine to Genode appeared to be quite a challenging task, since
officially only Linux, Windows and macOS are supported and most of the
qtwebengine code, which also contains a huge amount of third-party libraries,
is not built with qmake for the most part like other Qt modules, but with the
Ninja build system.

Fortunately, the situation turned out to be less problematic than expected, at
least with regard to the initial goal of getting a lightweight web browser
running and displaying regular web sites comparably to Arora. One reason for
that is that there already existed a qtwebengine port for FreeBSD, which
resolved most of the possible libc compatibility problems and thus served as
the basis for the Genode port. There were still some operating system specifics
in the code which had to be dealt with, though, like supporting shared memory
with 'mmap' or cache maintenance for JIT-compiled JavaScript code. Advanced web
engine features like multimedia support are disabled at the moment, also some
security-related features like the verification of server certificates
(requires a port of libnss), multi-processing or sandboxing.

The build system issue could eventually be resolved by adding a Genode platform
backend for qmake and passing the correct compiler options to the Chromium build
system.

As qtwebengine-based web browser we chose the [https://www.falkon.org - Falkon]
browser, which was previously known as 'QupZilla' and looks quite promising so far.


XXX screenshot


The Arora web browser and qtwebkit module are no longer available in this release.


Base framework and OS-level infrastructure
##########################################

Base API/ABI changes
====================

Synchronization primitives
~~~~~~~~~~~~~~~~~~~~~~~~~~

With the current release, we wrap up the
[https://genode.org/documentation/release-notes/20.05#Migration_from__Lock__to__Mutex__and__Blockade_ - migration]
of the code base from the 'Lock' to the 'Mutex' and 'Blockade' types to
improve diagnostics and clear the path towards future performance
optimizations.


Moved atexit handling from base library to C runtime
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Traditionally, Genode's base library took care of the execution of 'atexit'
handlers as this mechanism was regarded as fundamental to both C and C++.
In particular, the C++ compiler automatically generates calls to the
'__cxa_atexit' function of the C++ ABI for objects instantiated as local
static variables so that the destructors of such objects are called at the
exit of the program.

With the transition to Genode's modern component API (introduced in version
[https://genode.org/documentation/release-notes/16.05#New_component_API - 16.05]),
this mechanism became irrelevant for plain Genode components.
But for higher-level components that rely the C runtime, in particular POSIX
applications, this mechanism remained crucial. Hence, we did no question the
presence of the atexit mechanism in Genode's base library for a long time.

However, we ultimately realized that the atexit functionality must be
moved from the base library into the C runtime to fully adhere the
[https://genode.org/documentation/release-notes/17.02#New_execution_model_of_the_C_runtimed- execution model]
of the C runtime. Atexit handlers may perform I/O such as the closing and
syncing of files after all.

This change has the positive effect of reducing the complexity of the base
library. Furthermore, it overcomes the limitations of the formerly statically
dimensioned array of atexit handlers, which was wasteful for plain Genode
components, yet insufficient for complex POSIX applications.

Note that this change deliberately renders the atexit mechanism for plain
Genode components (without C runtime) ineffective. Genode components that used
to rely on the 'genode_exit' function for calling cleanup code must be changed
to explicitly call cleanup code.

This change also removes the implicit call of 'genode_exit(1)' by 'abort',
which is triggered by, i.e., uncaught exceptions. Scenarios that relied on
the former behavior for component monitoring should be changed to use
[https://genode.org/documentation/release-notes/18.11#Component_health_monitoring - heartbeat monitoring]
mechanism instead.

As another minor but still noteworthy detail, shared-library destructors are
no longer called via the atexit mechanism by explicitly by the dynamic linker.
This slightly changes the call order of destructors: Functions marked as
destructors are called after the libc-managed atexit handlers now.


Removal of deprecated interfaces
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Unsafe 'Xml_node' methods
-------------------------

The unsafe 'Xml_node' methods marked as deprecated in the
[https://genode.org/documentation/release-notes/20.05#Deprecation_of_unsafe__Xml_node__methods - previous release]
have been removed now.


Cancel-blocking interface
-------------------------

Closely related to the revised synchronization primitives mentioned above,
we removed the outdated 'Cancelable_lock' API along with the
underlying cancel-blocking mechanism, which had became obsolete by now. In
past times, this mechanism was employed to cleanly wind down threads that are
blocked at their destruction time. The move of Genode's API design away from
blocking RPC to asynchronously working components marginalized the problem to
the point where it ceased to exist.


Delayed dispatch of 'Rpc_entrypoint'
------------------------------------

Similar to the cancel-blocking mechanism, the ability to delay the dispatching
of RPC requests until an explicit call of 'Rpc_entrypoint::activate' is an API
relic from a time when each RPC server was multi-threaded. The modern flow of
execution has become much simpler, eliminating the need for this feature.


C runtime
=========

commit 87b08d6c7f06b9cde1857528bd778e767ca92295
Author: Alexander Boettcher <alexander.boettcher@genode-labs.com>
Date:   Thu Jun 4 16:04:29 2020 +0200

    libc: support pthread placement configuration
    
    Up to now all pthreads get placed on one CPU.
    
    The patch adds support to evaluate a libc pthread configuration specifying
    a placement strategy.
    
    The default strategy is now to use all available CPUs as imposed by Genode's
    affinity configuration for the pthread application.
    
    The old behaviour, putting all pthreads on one single cpu can be still
    configured by:
    
    <libc>
     <pthread placement="single-cpu"/>
     ...
    </libc>
    
    Fixes #3775

commit 1ec823bf5e55058f3ba3095b3b3305fb16318f66
Author: Alexander Boettcher <alexander.boettcher@genode-labs.com>
Date:   Tue Jun 16 13:50:21 2020 +0200

    libc: support manual pthread configuration
    
    Fixes #3787

commit a123c4dbb6611b819b084f0656ab7b38aad3beec
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Mon Jul 13 09:16:32 2020 +0200

    libc: cleanup monitor implementation
    
    - Explicit types for function and monitor execution results
    - Remove pending flag and mutex (pending flag was moved to kernel)

commit a115ebc9b6d7417004e8ac53de001e4d751e64e9
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Mon Jul 13 08:59:08 2020 +0200

    libc: process VFS operations in monitor
    
    Fixes #2635


Standard C++ library
====================

We enabled support for thread-related features like 'std::thread' or
'std::mutex' in the stdcxx library.


Ada/SPARK support
=================

With the development of the [Consistent Block Encrypter], Genodes Ada/SPARK
support was used in the context of a more complex software project for the
first time. Therefore, we felt the necessity to make up our minds about a
generally accepted Ada/SPARK coding-style as long as this step still doesn't
entail the painstaking adaption of large amounts of code.

Fortunately, the GNAT compiler flags assist developers a lot in this affair.
That said, we added the consideration of two new environment Make-variables to
the Genode toolchain: 'CC_ADA_WARN' and 'CC_ADA_WARN_STRICT'. Analogously to
the C++ pendants ('CC_CXX_WARN' and 'CC_CXX_WARN_STRICT'), the variable
'CC_ADA_WARN' denotes the common warning-configuration of the compiler for
Ada/SPARK while 'CC_ADA_WARN_STRICT' by default applies additional
configuration for a much higher level of strictness. This strict mode might be
deactivated locally for code which isn't subject to the Genode coding style -
e.g. ported third party code - by adding 'CC_ADA_WARN_STRICT = ' to the
corresponding Make files.

The common warning configuration for Ada/SPARK merely enables all warning
messages with the '-wa' flag. As with C++, the strict mode furthermore causes
GNAT to treat warnings like errors and refrain from compiling affected
Ada/SPARK code. In addition to that, the strict mode releases a broad variety
of checks for potential pitfalls and style consistency using the configuration
'-gnatyyBdSux' (which is compatible to the GNAT standard style). A
comprehensive description of all checks activated by this configuration would
be beyond the scope of this document. So, please have a look at the
[https://gcc.gnu.org/onlinedocs/gnat_ugn/Style-Checking.html - GNAT style-checking reference]
instead if you're interested.

Besides the style enforced through compiler flags, we decided to generally
promote "Camel-Snake Casing" for Ada/SPARK code. The only exceptions from that
form abbreviations of initials that are completely upper case and language
keywords that are completey lower case. This would be a conform snippet of
code:

! function T1_Node_XML_Tag_Open (
!    Node     : Type_1_Node_Type;
!    Node_Idx : Type_1_Node_Block_Index_Type;
!    Show_Hsh : Boolean;
!    VBA      : Virtual_Block_Address_Type)
! return String;

Another minor improvement of Genodes Ada/SPARK runtime consists in the
added support for the exponential operator on integers.


Operating-system components
###########################

Consistent Block Encrypter
==========================

With the Genode 20.05 release, our
[https://genode.org/documentation/release-notes/20.05#Feature-completeness_of_the_consistent_block_encrypter - Constistent Block Encrypter (CBE) reached feature completeness]
adding support for
[https://genodians.org/m-stein/2020-06-07-cbe-rekeying - online rekeying]
and
[https://genodians.org/m-stein/2020-06-08-cbe-resizing - online resizing].
Furthermore, we were able to run a Linux virtual machine using a CBE device as
system partition. During the last three months, we mainly reviewed and
consolidated the code but also improved the integration in a notable way.

One important step forward is that we implemented a new _reference_ Trust
Anchor. The Trust Anchor (TA) is a separate entity (might be a smartcard, a USB
dongle, or a piece of software) that the CBE relies on for key management and
for storing superblock hashes. In contrast to the dummy TA we used for testing
so far, the reference TA stores private key and superblock hashes persistently
through a file-system back-end and requires the user to enter a passphrase to
be unlocked. This enables the CBE to actually verify that the CBE device is in
the same state that it was left in the last time and that only authorized users
can access its data.

Furthermore, both the Crypto and the TA back end of the CBE are now integrated
through VFS plugins. This change gives the user of the CBE more flexibility in
two ways. On one hand, he can switch between integrating those entities locally
(inside the CBE driver) or remotely (in a VFS server instance isolated from
the CBE driver) by merely altering the system configuration.

[image cbe_integration - Three different ways to integrate the CBE]

On the other hand, the implementation of the Crypto entity and the Trust
Anchor can now be switched through means of configuration alone. For instance,
let us take a look at the VFS server in the CBE test scenario
'repos/cbe/run/vfs_cbe.run':

! <start name="vfs_cbe" caps="120">
!   <config>
!     <vfs>
!       <cbe_crypto_aes_cbc name="cbe_crypto"/>
!       ...
!     </vfs>
!     ...
!   </config>
!   ...
! </start>

We may replace the plugin employing an AES-CBC ESSIV block-cipher in this test
with one using plain memcopy (in other words: disabling block encryption) by
changing only one line:

! <start name="vfs_cbe" caps="120">
!   <config>
!     <vfs>
!       <cbe_crypto_memcopy name="cbe_crypto"/>
!       ...
!     </vfs>
!     ...
!   </config>
!   ...
! </start>

The memcopy example may in fact be useful for contexts where only the abilities
of the CBE to manage snapshots and to ensure consistency are of interest and
encryption would only generate unnecessary overhead. However, the main
motivation behind this is to allow for an easy application of other cipher
algorithms.

In order to make things even more approachable, the VFS-plugin-related code
between CBE, Crypto entity, and Trust Anchor relies on generic interfaces.
This simplifies supporting other existing cryptographic algorithms and TA
types as enabling them boils down to solely implementing a handfull of well
defined hook functions.

As for the CBE demo scenario that we published with the last Genode release:
The corresponding packages moved from the package source 'cnuke' to 'mstein'.
Furthermore, the CBE demo is now based on the unaltered Genode master branch
and the new master branch in the CBE repository itself. Besides that, for the
most part, the procedure for reproducing the demo described in the
[https://genodians.org/m-stein/2020-06-12-cbe-linux-vm - demo article] and the
[https://genodians.org/m-stein/2020-06-17-cbe-linux-vm-video - demo video] remained
the same. But be prepared to find minor discrepancies.


Virtual file system (VFS)
=========================

We extended the 'zero' VFS plugin to limit the amount of data, e.g., 0s,
it will provide. By setting the 'size' attribute a reader is restricted to
only consume data up to the specified amount per VFS handle. Through that
is serves as natural EOF. The attribute is parsed as 'Number_of_bytes', which
caps the amount to the maximum of the addressable memory on the platform.

This addition comes in handy when needing to provide a synthetic empty file
with a fixed size:

! <vfs>
!   <ram/>
!   <import>
!     <zero name="block_file" size="32M"/>
!   </import>
! </vfs>


Furthermore, we added an option the 'terminal' VFS plugin to ignore control
characters. Usually this plugin is used in interactive configurations where
reacting to control characters, e.g. ^C, is vital. That being said, the plugin
lends itself as general transport mechanism for low-traffic data transfers.
Those transfers, however, may contain arbitrary data that could very well be
interpreted as control characters. Therefor, we introduced the 'raw'
configuration attribute. Setting the attribute instructs the plugin to pass
all data through as-is without further interpretation.

! <vfs>
!   <dir name="/dev">
!     <terminal name="io" raw="yes"/>
!   </dir>
! </vfs>


Block server backed by VFS content
==================================

This release adds a new component that provides access to a VFS file
through a Block session. Block requests will be translated to VFS requests
operating directly on the file.

The client access is configured by setting the attributes of the 'policy'
node appropriately. The assumed block size of the underlying file must be
specified via the 'block_size' attribute. It defaults to 512 bytes.

The block count is determined by querying the file and dividing its size by
the block size. Pseudo file systems which do not return a proper size in their
'stat' implementation will therefore not work. The 'writeable' attribute
denotes if the Block session is allowed to perform write requests. However,
if the underlying file is read-only such requests will nonetheless
fail. The default value is 'no'.

The following snippets shows a configuration where the 'vfs_block' component
allows the component 'the_client' writeable access to the 'ext2_disk.img'
file. In return, this file is accessed via a file-system session.

! <start name="vfs_block">
!   <resource name="RAM" quantum="3M"/>
!    <provides> <service name="Block"/> </provides>
!      <config>
!
!        <vfs>
!          <fs buffer_size="2M" label="backend"/>
!        </vfs>
!
!        <policy label="the_client" file="/ext2_disk.img" block_size="512"
!                writeable="yes"/>
!      </config>
!      <route>
!        <service name="File_system" label="backend>
!          <child name="fs_provider"/> </service>
!        <any-service> <parent/> </any-service>
!      </route>
! </start>

As the 'vfs_block' is by using the VFS library flexible enough to cover the
use-cases of components like 'ram_block' and 'rom_block' we decided to remove
them.

For example a typical 'rom_block' use-case is implemented by using this
configuration:

! <start name="vfs_block">
!   <resource name="RAM" quantum="2M"/>
!    <provides> <service name="Block"/> </provides>
!      <config>
!
!        <vfs>
!          <rom name="genode.iso"/>
!        </vfs>
!
!        <default-policy file="/genode.iso" block_size="2048"/>
!      </config>
!      <route>
!        <any-service> <parent/> </any-service>
!      </route>
! </start>

On a technical note, the server currently only allows for one active session
and manages only one pending back end request but can easily be extended in the
future.


Device drivers
##############

;@skalk

commit 91b71f7a9ff0cd51d184add0d7f4c8abe36ef10e
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Wed Jun 24 10:48:36 2020 +0200

    run: add drivers_interactive for panda and arndale

commit 401c7f9a9f217432d1ec679484df82b677760466
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Fri Jul 10 13:04:12 2020 +0200

    base: extend PD session with managing_system call
    
    Introduce the managing_system privilege for components like the
    platform_driver to allow it to call system management functionality
    that is reserved by kernel or special firmware, e.g., ARM Trusted Firmware.
    
    The former RAM resource configuration attribute `constrain_phys`,
    which enabled to constrain the region of physical RAM to be used,
    gets replaced by the new, broader managing_system configuration
    attribute of a `start` node. It gets enforced by the sandbox library.
    
    Ref #3816

commit 3e061e4bcfaee33a734d7a163f2347c86d46bb05
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Fri Jul 10 13:39:49 2020 +0200

    hw: implement Pd_session::managing_system for ATF
    
    To access the ARM Trusted Firmware from the platform driver
    fill the new `managing_system` call of the PD session with life resp.
    do a SMC call on behalf of the client.
    
    Fix #3816

commit 11bad0e32cc8b7089d984ab0474007f7e566f096
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Fri Jul 17 18:28:06 2020 +0200

    os: add platform driver for i.MX 8M Quad SoC
    
    The new platform driver supports clock and power-domain settings per device.
    IOMUX constroller settings are not part of the driver yet.
    
    Fix #3863

commit d3872f4b9cc276a859d4f93cbd510b9a25c54cf4
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Fri Aug 21 17:51:48 2020 +0200

    os: disable initialization of i.MX8MQ platform_drv
    
    This is a temporary workaround to not harm drivers, which aren't
    converted yet to request all device resources including power and
    clocks from this new platform driver.
    
    Ref #3863

commit b7506a2a68a080345c9e11776c32863439911aff
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Fri Aug 21 13:00:04 2020 +0200

    hw: unify irq enumeration for Raspberri Pi
    
    By now, the enumeration of peripheral interrupts on Raspberry Pi 1 was
    different in between base-hw kernel and Fiasco.OC. Therefore, hacks were
    needed in every driver to request the correct interrupt number dependent
    on the kernel. Before reproducing the same in the platform driver for rpi,
    we can more easily use the same enumeration with base-hw.
    
    Ref #3864

commit 73bc2c3a80483f45672095f3d7848ee3e4bdfc70
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Fri Aug 21 13:54:05 2020 +0200

    os: add new platform driver for Raspberry Pi
    
    Fix #3864

commit 2b32b8fab768ea25613141531a89a607e22a3473
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Fri Aug 21 13:57:30 2020 +0200

    dde_linux: decouple Lx_kit::Irq and Platform::Device
    
    The Lx_kit::Irq abstraction of DDE Linux was always using the very first
    interrupt of a Platform::Device stored in it. Instead of handing over the
    platform device it is much more flexible and sane to hand over the actual
    interrupt capability.
    
    Ref #3865

commit b82025b6d9cc2a6611f5d6a26b48e9479945f87f
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Fri Aug 14 14:58:03 2020 +0200

    dde_linux: use new platform API for usb_host_drv
    
    Introduce a common platform device initialization routine for all
    ARM SoCs by using the new platform driver API.
    
    Fix #3865


Libraries and applications
##########################

Migration of ported software to Genode-World
============================================

In the previous releases, we continuously relieved the Genode main repository
from features that receive no continuous maintenance. Rather than dropping
such features, they find a new home at the
[https://github.com/genodelabs/genode-world - Genode-World] repository.
We foster this distinction to avoid wrong expectations. Whereas the code of
the Genode main repository is subjected to rigid quality assurance at Genode
Labs, the content of the World repository is tested and maintained in a rather
ad-hoc fashion.

The current release moves the Solo5 runtime (originally added in version
[https://genode.org/documentation/release-notes/18.11#Genode_as_a_platform_for_Mirage-OS_unikernels - 18.11])
and the stubby DNS tool to the Genode-World repository.


New ported 3rd-party software in Genode-World
=============================================

Port of SDL 2.0.14
------------------

As more and more software requires SDL2 it became necessary to support it
as well in addition to the already existing support for SDL1. We therefore
ported the upcoming version to Genode.

For the time being its functionality is limited in constrast to the SDL1
port - only input and unaccelerated video is supported - but will be extended
in the future to also cover the other subsystems.

Even in its limited state it is plenty as it allows for
[https://www.genodians.org/alex-ab/2020-07-02-scrcpy - Streaming Android to Genode using Scrcpy].

Port of iperf2
--------------

;@rolandbaer

commit 48b76d1d6d0889347be5e08bab8832175c15f561
Author: rolandbaer <rbaer@gmx.ch>
Date:   Sat Aug 8 00:03:21 2020 +0200

    Port of iperf2
    
    The run script is based on the netperf run scripts.
    
    Fixes #221

Port of gRPC
------------

_This work is a contribution by Pirmin Duss of_
_[https://gapfruit.com - Gapfruit]. Thanks for this welcome update._

At gapfruit, we wanted to provide an efficient way to combine a Genode system with
existing cloud environments. For that we ported the gRPC/protobuf libraries
and tool chain to Genode. For this release, we simplified the tool chain so
it does not depend on any packages of your Linux distribution.
Additionally, we fixed a memory leak and updated the port to gRPC
version 1.28.1 and protobuf version 3.11.2.


Removal of orphaned 3rd-party ports
===================================

The dde_zircon device-driver environment was added in
[https://genode.org/documentation/release-notes/18.08#Experimental_runtime_for_Zircon-based_drivers - 18.08]
as an experiment for executing device drivers of Google's Fuchsia OS as Genode
components. However, since the initial import of the feature, it remained
unused and received no further development. As Fuchsia largely diverged from
the APIs implemented by dde_zircon in the meantime, we decided to remove the
feature.


Sculpt OS improvements
######################

The Genode-based [https://genode.org/download/sculpt - Sculpt] operating
system has been updated to the new Genode version without major user-visible
changes. Given the fact that this release turned the low-level GUI stack
upside down (Section [The GUI stack, restacked]), this must be read as *good*
news. The GUI-stack changes have several nice side effects:

* The elimination of color-space conversions in the pixel-data path has
  noticeably improved the interactive latency. Sculpt OS has never been
  as snappy as now.

* As Sculpt's base system no longer depends on the successful initialization
  of the framebuffer and user-input devices, the administrative user interface
  can be started even before the low-level drivers are ready, increasing the
  parallelism at boot time. Yes, Sculpt OS boots even faster now.

* The now ubiquitous use of 32-bit pixels throughout the whole GUI stack has
  largely eliminated the need for dithering, thereby improving the visual
  clarity of the user interface. Dithering remains in use in some situations
  though. In particular to reduce quantization artifacts for the alpha channel
  of the leitzentrale overlay.


Interactive CPU affinity configuration
--------------------------------------

The component-configuration dialog gained the new ability to restrict the
component to a subset of CPUs. This option is available under the "Resource
assignment" sub menu.

[image sculpt_affinity]

The configuration dialog shows a matrix of CPU cores whereas the X axis
denotes the physical cores and the Y axis the hyperthreads. By default, all
available CPU cores are selected. The user can toggle the nodes by clicking on
them. The dialog ensures that the selection is always a rectangular area. So
one click may affect nodes other than only the clicked one.


Fail-safe handling of unsupported partition tables
--------------------------------------------------

Sculpt now uses Genode's heartbeat-monitoring mechanism to detect the failure
of part_block instances during storage discovery. This situation can happen
whenever a storage device contains an unsupported partitioning-table format.
In this case or other error cases, the discovery would fail to complete. The
new version of Sculpt responds to this situation by removing the unresponsive
part_block instance automatically, releasing the corresponding device. This
leaves the device available for alternative uses, for example assigning it to
a virtual machine.


Platforms
#########

Execution on bare hardware (base-hw)
====================================

;@skalk

commit 04d8c859d8dc191d0919277a7d4dbb720ace0bf0
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Wed Jun 17 15:23:31 2020 +0200

    hw: enable branch predictor on rpi
    
    * Z-bit was never enabled for rpi1
    * Write buffer, and TCM bits are deprecated in this processor generation
      so do not use them
    
    Ref #3247

commit 1f91fd3f7de7e07ffb564849c0061ca21eb2a418
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Thu Jun 25 11:24:24 2020 +0200

    hw: scale imx8q_evk cpu to 1.5 GHz

