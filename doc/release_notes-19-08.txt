

              ===============================================
              Release notes for the Genode OS Framework 19.08
              ===============================================

                               Genode Labs



;intro
;@nfeske


Flexible keyboard layouts
#########################

;@chelmuth

Tracing
#######

Support for fast tracing has been built into Genode for a long time. However,
the stakes to take advantage of this feature remained high because convenience
functions where not in place. With the current release we added the support for
easy trace setups through a VFS plugin. The plugin is called _vfs_trace_ and can
be mounted into a Genode component as follows:

!<config>
!  <vfs>
!    <trace ram=32MB/>
!  </vfs>
!</config>

This configuration will create a trace-file system at the root of the VFS. The
_ram_ attribute is mandatory and determines the maximum size of all trace
buffers. The file system forms a recursive directory structure that represents
the parent/child relationship of running components, while the leaf directories
represent single threads within a component. Each leaf directory currently
contains three files:

:'enable': Start or stops tracing of a thread by write "true" or "false" into
           file.

:'buffer_size': Allows the configuration of the trace-buffer size for the
                thread in the usual Genode format (e.g. 5M, 512K, 1024).

:'trace_buffer': This read only file contains the current content of the trace
                 buffer. Every trace entry can only be read once, after that
                 only new entries appear. "tail -f" can also be used in order to
                 display continuous output.

As an example, tracing is started by writing _true_ to the _enable_ file:

! echo "true" > enable

The trace buffer can than be displayed using Unix tools like _tail_

! tail -f trace_buffer

which provides a continuous output.

Additionally, we have a added the _trace_ function to _base/log.h_ that
facilitates identical functionality as _Genode::log_

! Genode::trace("Tracepoint value: ", value);

In order to enable tracing the parent must provide the "TRACE" service. For a
real world example on Sculpt OS please refer to this
[http://genodians.org/ssumpf/2019-06-18-trace_fs - Genodians article].

With the _vfs_trace_ plugin in place we removed the outdated _trace_fs_.


Consolidation of the C runtime and Noux
#######################################

On our [https://genode.org/about/road-map#August_-_Release_19.08 - road map],
we vaguely hinted at our plan for the "consolidation" of the noux runtime,
which is actually meant as a polite way of saying that we are going to
remove it. We introduced the
[https://genode.org/documentation/release-notes/11.02#Noux_-_an_execution_environment_for_the_GNU_userland - Noux runtime]
in 2011 as way to execute command-line-based GNU software directly on
Genode. It has served us well over the years and is - in fact - a crucial
ingredient of Sculpt OS and other system scenarios such as the Genodians.org
web server. Noux supplements Genode with two valuable assets, namely
a flexible and expandable virtual file system (VFS) layer, and the implementation
of the
[https://genode.org/documentation/release-notes/12.02#Noux_support_for_fork_semantics - Unix way]
to spawn applications ('fork' and 'execve').

In the
[https://genode.org/documentation/release-notes/17.02#Enhanced_VFS_infrastructure - meantime],
noux' VFS implementation has become independent from the noux runtime and
is now prominently employed by Genode's C runtime and the VFS server
component. Genode's C runtime became more and more complete, alleviating
the use of noux as POSIX compatibility layer except for programs that
depend on a working implementation of 'fork' and 'execve'.

The current release fills this remaining gap in Genode's C runtime by
providing 'fork', 'execve', and cousins such as 'wait4' and 'getpid' as
regular parts of the libc. This will eventually make noux redundant.

Note that this change does *NOT* make Genode reliant on POSIX.
the C runtime including the Unix features are entirely optional.

As one stepping stone of this undertaking, noux applications, which had
previously be compiled for noux, have become binary compatible with the
regular C runtime. So one can run programs like 'bash' directly as
Genode component without any friction.

There are a few collateral improvements of Genode's dynamic linker and the C
runtime on the account of the new 'fork' and 'execve' implementation. E.g., in
addition to the already supported 'stdin', 'stdout', and 'stderr'
configuration, the libc can be instructed to initialize arbitrary file
descriptors as follows:

! <config>
!   ...
!   <libc ...>
!     <fd id="3" path="/dev/log" writeable="yes" readable="no" seek="10"/>
!     ...
!   </libc>
! </config>

The libc-based implementation of 'fork' and 'execve' can be tried out via
the new _ports/run/bash.run_ script. Note that there are still a number of
limitations such as the lack of signal and ioctl handling. Pipes are not
supported, and shebangs ('!#') are not interpreted yet. That said, once those
missing pieces come into place, we can fade out the use of noux within Genode.


64-bit ARM and NXP i.MX8
########################

64-bit ARM support in our custom base-hw kernel
===============================================

By introducing rudimentary Raspberry Pi 3 support on top of the Fiasco.OC
kernel in the last release, the first ARM 64-bit support entered the Genode OS
framework. We pursued the ARM 64-bit path and introduce support for Raspberry Pi
3 as well as the i.MX8 evaluation kit (EVK) this time using our own base-hw
kernel.

Noteworthy additions in the base-hw kernel are support for the AARCH64 system
level architecture, and the use of the modern GIC v3 interrupt controller on top
of the i.MX8 EVK board.
In comparison to the GICv2, GICv3 adds support for more than eight
CPUs, more than 1020 interrupt IDs, and offers fast register access to the CPU
interface, instead of MMIO access.
Minor changes had to be made to the page-table
implementation of ARMv7 with Large Physical Address Extension (LPAE) to re-use
it for ARMv8. Moreover, the TLB maintenance kernel internal API needs to be
changed slightly for all ARM platforms.

Currently, the Raspberry Pi 3 platforms gets regularly tested using Qemu.
In contrast we use the i.MX8 EVK physical hardware to test this platform.
Both platforms are driven with a single cpu core only for the moment.


Kernel-agnostic network driver for i.MX8
========================================

;@cproc

commit 4dafdbd5b75da7632d84b4411c1148431979f93c
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Fri Jun 21 15:04:03 2019 +0200

    dde_linux: update 'fec' driver to version 4.16.3
    
    Fixes #3432

commit 5dd1abcc2da7fae757e34989c971c53954114b0c
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Thu Jun 27 19:41:57 2019 +0200

    depot: add recipe for drivers_nic-imx7d_sabre
    
    Fixes #3433

commit 71ce1442c8cc97e552214b75b3a9fe4e3c7723a0
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Thu Jun 27 19:42:01 2019 +0200

    run: enable 'imx7d_sabre' in network tests
    
    Fixes #3434

commit 38dcdeeb049da5ff4132b0a39dbe5ad13bdb88f1
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Thu Jul 4 15:54:19 2019 +0200

    fec_nic_drv: arm_64 support
    
    Fixes #3446

commit 91c8e70bef31b0d9cadc162d2cec46b789a236ea
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Thu Jul 4 15:54:19 2019 +0200

    depot: add recipe for drivers_nic-imx8q_evk
    
    Fixes #3452


Enhanced packaging and test infrastructure for ARMv8
====================================================

Within this release cycle we enabled additional infrastructure for ARMv8
platforms. For example, Noux packages - like _coreutils_, _bash_ - are now
available, the standard C++ library is in place, and support for Genode's port of
the Linux TCP/IP stack is enabled. Also, ARMv8 can now be executed on the
Fiasco.OC kernel.

Additionally, we enabled nightly testing within our _depot_autopilot_ tool on ARMv8.


Base framework and OS-level infrastructure
##########################################

General system time concept
===========================

Briefly speaking, up to now there has been no notion of an overall concept of
system time in Genode. Components that need to have access to some kind of real
time are either configured locally, e.g. libc-based components access a
configured “device” (/dev/rtc) which just might be an inline file system
containing an artifical timestamp or the VFS RTC plugin, and other components
query some RTC session directly. Most of the time this session is provided by
the 'rtc_drv' on x86 machines, which is somewhat costly as reading the RTC via
I/O ports takes time and is therefore done scarcely. For example, the libc will
query an RTC source only once and uses this initial value to interpolate the
current time. However, for executing long-running components, it will be
necessary to adjust the clock to compensate for any occurring clock drift or to
correct a mis-configured clock in general. In addition, it is desirable to be
able to use a remote time source, e.g., an NTP-server, to synchronize the
system time.

To address this, we came up with the following concept

[image system_rtc]

The new "System RTC" component, located at
'repos/libports/src/server/system_rtc', acts as proxy for the RTC service in
front of the actual RTC driver. It uses the driver to get the initial RTC value
and then uses a Timer session (via the timeout framework) to locally
interpolate the time. In contrast to querying the RTC driver querying the
System RTC is fast.

The RTC driver and the System RTC are bundled up together in the new
'drivers-rtc-pc' package. The runtime of this package requests two ROM modules
used to update the RTC value. The first one, named 'system_set_rtc', is used to
update the proxy component while the second one, called 'hw_set_rtc', is used
by the RTC driver to write the value into the battery-backed RTC.  A different
component, potentially accessing a remote time source, may write to these ROMs
to adjust the time in the packages runtime.

The new native SNTP client in 'repos/libports/src/app/sntp_client' is such a
component. It periodically requests the current time from a given SNTP server
and reports it. The report produced by the component contains the time as GMT.
Depending on the system policy, it can be used to update the time of the System
RTC or/and to instruct the driver to set the RTC value.

To propagate such changes to RTC values, the RTC session was enhanced by the
new 'set' signal. A client of the session can install a signal handler to adapt
it's own time when necessary. Based on this, the time backend of the libc was
changed to instantiate a Watch Handler for the RTC device, which, when
triggered, will cause the libc to re-read the RTC value.

This constellation should, under normal operation, allow for second to
sub-second granularity updates for the overall system time and avoid drifting
away from network time.


Accessing SMBIOS tables
=======================

The new native SMBIOS decoder in 'os/src/app/smbios_decoder' can be used on x86
to parse SMBIOS tables and report gathered information in a human-readable way.
Besides general table information like number and size of structures, etc., the
component supports full parsing of SMBIOS structures of types "BIOS", "System",
and "Baseboard".

The component is free from any code for acquiring an SMBIOS table through means
like bootloader or BIOS information. It expects a table to be present through a
normal Genode ROM session with label 'smbios_table'. This way, the underlying
system is required to find, select and safe the raw table on startup and create
a ROM module from it. This is currently achieved on NOVA and base-hw through an
interplay of kernel, Core component, and ACPI driver and was tested for legacy
BIOS as well as UEFI systems.


Clipboard
=========

Genode introduced a principle copy-and-paste mechanism already four years ago
[https://genode.org/documentation/release-notes/15.11#Copy_and_paste].
However, originally created as a part of the technology demo, the mechanism
remained unused in our day to day work with Genode. This changed now. We
took the integration of copy-and-paste support in Sculpt OS as an opportunity
to revive and refine the existing mechanism and supplement it with the
features needed to make it practical for daily use.

We believe that the result aligns ease of use nicely with security.
The concept is described in a dedicated article at Genodians.org:
[https://genodians.org/nfeske/2019-07-03-copy-paste].

On a technical level, the existing clipboard component received a new
option that allows for dynamic information-flow policies based on
user interactivity (keyboard focus, activity).
When setting the config attribute 'match_labels="yes"', the clipboard
performs plausibility checks for copy and paste operations against the
focus of the nitpicker GUI server. The clipboard policy - including
information-flow policies - has become reconfigurable.

To make window-manager clients compatible with the clipboard's dynamic
policy, the window manager got enhanced with the ability to proxy the
interaction with the clipboard.

GUI clients in turn - in particular the graphical *terminal* - became able
to interact with the clipboard.
With the '<config>' attribute 'copy="yes"' specified, the terminal allows
the user to select text to be reported to a "clipboard" report. The selection
mode is activated by holding the left shift key. While the selection mode
is active, the text position under mouse pointer is highlighted and the
user can select text via the left mouse button. Upon release of the mouse
button, the selection is reported.
Vice versa, with the '<config>' attribute 'paste="yes"' specified, the
terminal allows the user to paste the content of a "clipboard" ROM session
to the terminal client by pressing the middle mouse button.

Finally, we integrated those new abilities into Sculpt OS and to several
installable packages, including virtual machines, the noux-system package,
and graphical Qt5-based applications.


Enhanced SSH terminal
=====================

This release paves the way for remotely managing Genode devices over SSH.
Until now, only interactive SSH sessions were supported. It is now possible to
execute commands from a remote SSH client.
E.g., 'ssh noux@localhost -p 5555 "ls -hal /bin/'. For non-interactive
sessions, ssh_terminal requires a helper component. This component is
responsible to create the environment for the command to run in. You can find
an example for such a component in _gems/src/test/exec_terminal_.
It starts noux in a sub init and executes the provided command inside of it.
The new _ssh_exec_channel.run_ script gives a demonstration on how this
feature can be used.

This work is a contribution by [https://gapfruit.com - Gapfruit]. Thanks
for this great new feature!


Storage-stack improvements
==========================

The desire of one Genode developer to exchange data via Iomega ZIP drives
between an Atari Falcon and Sculpt OS called for a number of small
improvements across several components of the storage stack.

First, the USB-block driver has been changed to exit on an initialization
failure instead of waiting for another (supported) device. This change enables
the Sculpt manager to detect such conditions and release the USB device
hardware by removing the driver component. Such a failed initialization may
happen with exotic USB-storage devices such as ZIP drives. With the device
released, however, it can be assigned as to a virtual machine to access it
using a guest OS with a broader support of devices.

Second, the USB-block driver received new support for issuing the
SCSI START-STOP command at initialization time, thereby overcoming the
ZIP-drive initialization failure.

Third, we enhanced the part-block component with the ability to parse AHDI
partition schemes and detect the GEMDOS variant of FAT as used by Atari TOS.

Fourth, we enabled the Rump VFS plugin to access GEMDOS file systems. The
GEMDOS variant is supported by NetBSD's "msdos" file-system driver. However,
it must explicitly be enabled by a mount flag. Hence, we added the principle
ability for passing mount flags to NetBSD file-system drivers and enabled the
MSDOSFSMNT_GEMDOSFS flag based on the VFS plugin's config attribute
'gemdos="yes"'.

With these changes in place, data can now be exchanged directly between
Atari-formatted disks and Sculpt OS. That said, advanced use cases such as
media changes at runtime are not covered yet.


Updated Ada/SPARK runtime
=========================

Genode's Ada/SPARK runtime is developed and maintained by
[https://componolit.com - Componolit]. Thanks for this excellent
collaboration!

The updated Componolit Ada runtime 1.1.0 increases the proof coverage and
cleans up the source code structure. SPARK mode is now enabled wherever
possible and unneeded abstractions have been removed. Furthermore, the 64-bit
addition and subtraction have been proven to be free of runtime errors.
As a new feature, the runtime now supports the use of inline assembly in Ada.

The removal of unneeded features such as the incomplete threading support for
the secondary stack has greatly reduced the runtime's complexity while keeping
the current functionality available.
Also GNAT.IO has been removed as its implementation was incomplete and
complex. A simpler replacement has been introduced with
'Componolit.Runtime.Debug'.

Unrelated to Genode, the runtime now supports [https://muen.sk/ - Muen] and
the API/ABI of the runtime has been separated from the GNAT ABI.


Libraries and applications
##########################

Updated Qt5
===========

;@cproc

Virtualization
==============

As follow up of Genode's work on the 
[https://genode.org/documentation/release-notes/19.05#Kernel-agnostic_virtual-machine_monitors - kernel agnostic virtual monitor interface]
on x86, we added with this release principle support to run our port of
Virtualbox on Genode/Fiasco.OC. We write -principle- support, since we managed
to get the VMM running with Fiasco.OC, but unfortunately not all required
features by the VMM are available by the Fiasco.OC kernel, e.g. guest FPU
registers, PDPTE registers and task-priority support. In practice this means,
that the VMs with Windows and Linux come up to a certain point, but will fail
later whenever the guest state run out of synchronization between
VMM and hardware. In contrast, the Seoul VMM runs fine on Fiasco.OC since it
requires not the mentioned missing features.

Main working items had been the completion of transfer of the available guest
registers and control flow synchronization improvements between VMM and Fiasco.OC
kernel. Additionally, the usage of priorities for the Virtualbox pthreads in
the VMM had to been disabled. Finally, some tests for Virtualbox with
Genode/Fiasco.OC got enabled for nightly regular testing.



Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Tue Aug 13 14:05:23 2019 +0200

    vbox: add 'RTMemDupExTag()' implementation
    
    Fixes #3473


Disposable VM for handling captive portals
==========================================

It is common that local networks require you to interact with a specific web
page before gaining access to full network functionality. Such captive portal
pages are completely individual to the accessed network and not limited in the
use of common web techniques. Therefore, their handling is best be done using a
fully-featured web browser like the Mozilla Firefox.

This is were, in a Genode-based desktop system like Sculpt, a disposable VM for
hosting a minimal Browser setup becomes desirable. It's goal is to unlock a
network for the native Genode surroundings with as less inconvenience as
possible just to be thrown away afterwards without any side effects to the
system.

Now, one could use the Firefox appliance VM of Sculpt (see the
[https://genode.org/documentation/release-notes/18.05 - release notes] or the
[http://genodians.org/alex-ab/2019-03-06-disposal-browser-vm - genodians
article]) for this. But this VM aims for a long-term browsing experience which,
in the context of mere captive-portal handling, brings some drawbacks like
a much higher RAM consumption or the required sessions for USB detection and
shared folders.

Furthermore, in the captive portal VM, there's no need for managing windows or
browser tabs. The one browser tab needed can always be shown in fullscreen.
It is also unnecessary for the browser to maintain a content cache or remember
user data. This can reduce resource consumption.

The VM we came up with is provided as package for Sculpt through Martin Stein
(depot user 'mstein'). After enabling this user, the captive portal VM can be
found in the Sculpt menu under "Depot -> mstein -> Virtual Machines ->
vbox5-nova-captive-portal". The VM is based on a TinyCore 10 Linux with
Xserver, i3 WM, and a tailored Firefox browser. The package runtime doesn't
need access to your file system, it merely loads some ROMs into a RAM FS, so,
it will completely forget changes made during a session. Therefore, it's also
safe to simply remove an instance via the Leitzentrale component-view once you
don't need it anymore. The guest additions are also included to make the VM
window resizable.


Build system and tools
######################

;@chelmuth

commit 8d62f21b4058ad118b3de418006c28d3651c6ecc
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Fri Jun 14 16:18:58 2019 +0200

    autopilot: support arch-specific build directories
    
    Replace the notion of board-specific platforms by clear definition
    architecture and board.
    
    Also added new command line switch for "targets"
    
      -t <target>         test target as triple of architecture-board-kernel,
                          e.g., arm_v7a-pbxa9-hw
    
    Related to #3316
    Fixes #3417

