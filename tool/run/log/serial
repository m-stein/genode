##
# Get the output of the target machine via serial connection
#
# \param --log-serial-cmd   Cmd that is executed to capture the output
#

source [genode_dir]/tool/run/log.inc


set default_serial_cmd "picocom -b 115200 /dev/ttyUSB0"


proc log_serial_cmd { } {
	global default_serial_cmd
	return [get_cmd_arg --log-serial-cmd $default_serial_cmd]
}


##
# Log output of the test machine via serial device
#
proc run_log { wait_for_re timeout_value } {
	global output_spawn_id

	set kernel_msg [run_boot_string]

	#
	# Serial tends to be shaky on some devices, i.e., sending garbage that
	# is treated as EOF by expect(1). Therefore, we try several times to
	# start the serial capture process. We decrease the initial timeout on
	# each try to keep the original upper bound of the timeout.
	#
	# XXX the initial timeout was estimated by testing and is merely enough
	#     to load large scenarios via TFTP.
	#
	set timeout 210
	while {true} {
		set time_start [clock seconds]

		eval spawn [log_serial_cmd]
		set output_spawn_id $spawn_id

		expect {
			-i $output_spawn_id $kernel_msg { break; }
			eof         {
				set time_end [clock seconds]
				if {[expr $time_end - $time_start] <= 1} {
					incr timeout -1
				} else {
					incr timeout [expr -1 * ($time_end - $time_start)]
				}

				continue;
			}
			timeout     {
				puts stderr "Boot process timed out"
				close
				return false
			}
		}
	}

	wait_for_output $wait_for_re $timeout_value $output_spawn_id
	return true
}
